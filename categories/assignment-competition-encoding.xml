<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Kaggle (Posts about assignment competition encoding)</title><link>https://necromuralist.github.io/Kaggle-Competitions/</link><description></description><atom:link href="https://necromuralist.github.io/Kaggle-Competitions/categories/assignment-competition-encoding.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 27 Sep 2018 18:37:18 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Mean Encoding The Competition Data</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/#org8a23b36"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/#org2661788"&gt;General tips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/#orga40acc0"&gt;Read In the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/#orgb4827ea"&gt;Aggregate data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/#org01099f4"&gt;Mean encodings without regularization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/#org939b1a8"&gt;Method 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/#orgbd81024"&gt;1. KFold scheme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8a23b36" class="outline-2"&gt;
&lt;h2 id="org8a23b36"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8a23b36"&gt;
&lt;p&gt;
In this programming assignment you will be working with the &lt;i&gt;1C&lt;/i&gt; dataset from the final competition. You are asked to encode the &lt;code&gt;item_id&lt;/code&gt; in 4 different ways:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Via KFold scheme;&lt;/li&gt;
&lt;li&gt;Via Leave-one-out scheme;&lt;/li&gt;
&lt;li&gt;Via smoothing scheme;&lt;/li&gt;
&lt;li&gt;Via expanding mean scheme.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&lt;b&gt;&lt;b&gt;You will need to submit&lt;/b&gt;&lt;/b&gt; the correlation coefficient between the resulting encoding and the target variable up to 4 decimal places.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2661788" class="outline-2"&gt;
&lt;h2 id="org2661788"&gt;General tips&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2661788"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Fill NANs in the encoding with &lt;code&gt;0.3343&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Some encoding schemes depend on sorting order, so in order to avoid confusion, please use the following code snippet to construct the data frame. This snippet also implements mean encoding without regularization.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# python standard library
from itertools import product

# pypi
import pandas
import numpy

# this course (github)
from hse_graders.assignment_3.grader import Grader

# this project
from kaggler.course.data import Data
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga40acc0" class="outline-2"&gt;
&lt;h2 id="orga40acc0"&gt;Read In the Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga40acc0"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sales = Data().sales_training_data
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb4827ea" class="outline-2"&gt;
&lt;h2 id="orgb4827ea"&gt;Aggregate data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb4827ea"&gt;
&lt;p&gt;
Since the competition task is to make a monthly prediction, we need to aggregate the data to montly level before doing any encodings. The following code-cell serves just that purpose.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;index_cols = ['shop_id', 'item_id', 'date_block_num']
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
For every month we create a grid from all shops/items combinations from that month.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grid = [] 
for block_num in sales['date_block_num'].unique():
    cur_shops = sales[sales['date_block_num']==block_num]['shop_id'].unique()
    cur_items = sales[sales['date_block_num']==block_num]['item_id'].unique()
    grid.append(numpy.array(list(product(*[cur_shops, cur_items, [block_num]])),dtype='int32'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now turn the grid into a pandas dataframe.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grid = pandas.DataFrame(numpy.vstack(grid), columns = index_cols,dtype=numpy.int32)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Get the aggregated values for (&lt;code&gt;shop_id&lt;/code&gt;, &lt;code&gt;item_id&lt;/code&gt;, and &lt;code&gt;month&lt;/code&gt;).
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grouped = sales.groupby(index_cols, as_index=False).agg({'item_cnt_day':{'target':'sum'}})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Fix the column names.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grouped.columns = [column[0] if column[-1]=='' else column[-1] for column in grouped.columns.values]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Join the aggregated data to the grid.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;all_data = pandas.merge(grid, grouped, how='left', on=index_cols).fillna(0)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Sort the data.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;all_data.sort_values(['date_block_num','shop_id','item_id'], inplace=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org01099f4" class="outline-2"&gt;
&lt;h2 id="org01099f4"&gt;Mean encodings without regularization&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org01099f4"&gt;
&lt;p&gt;
Now that we have done the techinical work, we are ready to actually &lt;b&gt;mean encode&lt;/b&gt; the desired &lt;code&gt;item_id&lt;/code&gt; variable. 
&lt;/p&gt;

&lt;p&gt;
Here are two ways to implement mean encoding features &lt;b&gt;without&lt;/b&gt; any regularization. You can use this code as a starting point to implement regularized techniques. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org29096c0" class="outline-3"&gt;
&lt;h3 id="org29096c0"&gt;Method 1:  Calculate a mapping: {item_id: target_mean}&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org29096c0"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;item_id_target_mean = all_data.groupby('item_id').target.mean()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In our non-regularized case we just &lt;b&gt;map&lt;/b&gt; the computed means to the &lt;code&gt;item_id&lt;/code&gt;'s.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;all_data['item_target_enc'] = all_data['item_id'].map(item_id_target_mean)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgab3291f" class="outline-3"&gt;
&lt;h3 id="orgab3291f"&gt;Fill NaNs&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgab3291f"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;all_data['item_target_enc'].fillna(0.3343, inplace=True) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga241e6a" class="outline-3"&gt;
&lt;h3 id="orga241e6a"&gt;Print correlation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga241e6a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;encoded_feature = all_data['item_target_enc'].values
print(numpy.corrcoef(all_data['target'].values, encoded_feature)[0][1])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
0.48303869886216977
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org939b1a8" class="outline-2"&gt;
&lt;h2 id="org939b1a8"&gt;Method 2&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org939b1a8"&gt;
&lt;p&gt;
Unlike the  &lt;code&gt;.target.mean()&lt;/code&gt; function, &lt;code&gt;transform&lt;/code&gt; will return a dataframe with an index like in &lt;code&gt;all_data&lt;/code&gt;.
Basically this single line of code is equivalent to the first two lines from of Method 1.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;all_data['item_target_enc'] = all_data.groupby('item_id')['target'].transform('mean')
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org97e2052" class="outline-3"&gt;
&lt;h3 id="org97e2052"&gt;Fill NaNs&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org97e2052"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;all_data['item_target_enc'].fillna(0.3343, inplace=True) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7436eae" class="outline-3"&gt;
&lt;h3 id="org7436eae"&gt;Print correlation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7436eae"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;encoded_feature = all_data['item_target_enc'].values
print(numpy.corrcoef(all_data['target'].values, encoded_feature)[0][1])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
0.48303869886216977
&lt;/p&gt;


&lt;p&gt;
See the printed value? It is the correlation coefficient between the target variable and your new encoded feature. You need to &lt;b&gt;&lt;b&gt;compute the correlation coefficient&lt;/b&gt;&lt;/b&gt; between the encodings that you will implement and &lt;b&gt;&lt;b&gt;submit those to coursera&lt;/b&gt;&lt;/b&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grader = Grader()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbd81024" class="outline-2"&gt;
&lt;h2 id="orgbd81024"&gt;1. KFold scheme&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbd81024"&gt;
&lt;p&gt;
This is Explained starting at 41 seconds into the &lt;a href="https://www.coursera.org/learn/competitive-data-science/lecture/LGYQ2/regularization"&gt;Regularization lecture&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
First implement the KFold scheme with five folds. Use KFold(5) from sklearn.model_selection. 
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Split your data in 5 folds with &lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html"&gt;sklearn.model_selection.KFold&lt;/a&gt; with &lt;code&gt;shuffle=False&lt;/code&gt; (the default).&lt;/li&gt;
&lt;li&gt;Iterate through folds: use all but the current fold to calculate mean target for each level `item_id`, and  fill the current fold.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
See the &lt;b&gt;&lt;b&gt;Method 1&lt;/b&gt;&lt;/b&gt; from the example implementation. In particular learn what `map` and pd.Series.map functions do. They are pretty handy in many situations.
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all_data['target'].values, encoded_feature)[0][1]
print(corr)
grader.submit_tag('KFold_scheme', corr)
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all_data['target'].values, encoded_feature)[0][1]
print(corr)
grader.submit_tag('Leave-one-out_scheme', corr)
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all_data['target'].values, encoded_feature)[0][1]
print(corr)
grader.submit_tag('Smoothing_scheme', corr)
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all_data['target'].values, encoded_feature)[0][1]
print(corr)
grader.submit_tag('Expanding_mean_scheme', corr)
&lt;/p&gt;


&lt;p&gt;
STUDENT_EMAIL = # EMAIL HERE
STUDENT_TOKEN = # TOKEN HERE
grader.status()
&lt;/p&gt;


&lt;p&gt;
grader.submit(STUDENT_EMAIL, STUDENT_TOKEN)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>assignment competition encoding</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/</guid><pubDate>Mon, 24 Sep 2018 01:50:28 GMT</pubDate></item></channel></rss>