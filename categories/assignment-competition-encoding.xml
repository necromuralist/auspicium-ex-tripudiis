<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Kaggle (Posts about assignment competition encoding)</title><link>https://necromuralist.github.io/Kaggle-Competitions/</link><description></description><atom:link href="https://necromuralist.github.io/Kaggle-Competitions/categories/assignment-competition-encoding.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 25 Sep 2018 23:01:14 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Mean Encoding The Competition Data</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org8b6abd8" class="outline-2"&gt;
&lt;h2 id="org8b6abd8"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8b6abd8"&gt;
&lt;p&gt;
In this programming assignment you will be working with `1C` dataset from the final competition. You are asked to encode `item&lt;sub&gt;id&lt;/sub&gt;` in 4 different ways:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Via KFold scheme;&lt;/li&gt;
&lt;li&gt;Via Leave-one-out scheme;&lt;/li&gt;
&lt;li&gt;Via smoothing scheme;&lt;/li&gt;
&lt;li&gt;Via expanding mean scheme.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&lt;b&gt;&lt;b&gt;You will need to submit&lt;/b&gt;&lt;/b&gt; the correlation coefficient between resulting encoding and target variable up to 4 decimal places.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org32f5d8a" class="outline-2"&gt;
&lt;h2 id="org32f5d8a"&gt;General tips&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org32f5d8a"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Fill NANs in the encoding with `0.3343`.&lt;/li&gt;
&lt;li&gt;Some encoding schemes depend on sorting order, so in order to avoid confusion, please use the following code snippet to construct the data frame. This snippet also implements mean encoding without regularization.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;import pandas as pd
import numpy as np
from itertools import product
from grader import Grader
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
sales = pd.read&lt;sub&gt;csv&lt;/sub&gt;('../readonly/final&lt;sub&gt;project&lt;/sub&gt;&lt;sub&gt;data&lt;/sub&gt;/sales&lt;sub&gt;train.csv.gz&lt;/sub&gt;')
&lt;/p&gt;


&lt;p&gt;
index&lt;sub&gt;cols&lt;/sub&gt; = ['shop&lt;sub&gt;id&lt;/sub&gt;', 'item&lt;sub&gt;id&lt;/sub&gt;', 'date&lt;sub&gt;block&lt;/sub&gt;&lt;sub&gt;num&lt;/sub&gt;']
&lt;/p&gt;

&lt;p&gt;
grid = [] 
for block&lt;sub&gt;num&lt;/sub&gt; in sales['date&lt;sub&gt;block&lt;/sub&gt;&lt;sub&gt;num&lt;/sub&gt;'].unique():
    cur&lt;sub&gt;shops&lt;/sub&gt; = sales[sales['date&lt;sub&gt;block&lt;/sub&gt;&lt;sub&gt;num&lt;/sub&gt;']==block&lt;sub&gt;num&lt;/sub&gt;]['shop&lt;sub&gt;id&lt;/sub&gt;'].unique()
    cur&lt;sub&gt;items&lt;/sub&gt; = sales[sales['date&lt;sub&gt;block&lt;/sub&gt;&lt;sub&gt;num&lt;/sub&gt;']==block&lt;sub&gt;num&lt;/sub&gt;]['item&lt;sub&gt;id&lt;/sub&gt;'].unique()
    grid.append(np.array(list(product(*[cur&lt;sub&gt;shops&lt;/sub&gt;, cur&lt;sub&gt;items&lt;/sub&gt;, [block&lt;sub&gt;num&lt;/sub&gt;]])),dtype='int32'))
&lt;/p&gt;

&lt;p&gt;
#turn the grid into pandas dataframe
grid = pd.DataFrame(np.vstack(grid), columns = index&lt;sub&gt;cols,dtype&lt;/sub&gt;=np.int32)
&lt;/p&gt;

&lt;p&gt;
#get aggregated values for (shop&lt;sub&gt;id&lt;/sub&gt;, item&lt;sub&gt;id&lt;/sub&gt;, month)
gb = sales.groupby(index&lt;sub&gt;cols,as&lt;/sub&gt;&lt;sub&gt;index&lt;/sub&gt;=False).agg({'item&lt;sub&gt;cnt&lt;/sub&gt;&lt;sub&gt;day&lt;/sub&gt;':{'target':'sum'}})
&lt;/p&gt;

&lt;p&gt;
#fix column names
gb.columns = [col[0] if col[-1]=='' else col[-1] for col in gb.columns.values]
#join aggregated data to the grid
all&lt;sub&gt;data&lt;/sub&gt; = pd.merge(grid,gb,how='left',on=index&lt;sub&gt;cols&lt;/sub&gt;).fillna(0)
#sort the data
all&lt;sub&gt;data.sort&lt;/sub&gt;&lt;sub&gt;values&lt;/sub&gt;(['date&lt;sub&gt;block&lt;/sub&gt;&lt;sub&gt;num&lt;/sub&gt;','shop&lt;sub&gt;id&lt;/sub&gt;','item&lt;sub&gt;id&lt;/sub&gt;'],inplace=True)
&lt;/p&gt;


&lt;p&gt;
item&lt;sub&gt;id&lt;/sub&gt;&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;mean&lt;/sub&gt; = all&lt;sub&gt;data.groupby&lt;/sub&gt;('item&lt;sub&gt;id&lt;/sub&gt;').target.mean()
&lt;/p&gt;

&lt;p&gt;
all&lt;sub&gt;data&lt;/sub&gt;['item&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;enc&lt;/sub&gt;'] = all&lt;sub&gt;data&lt;/sub&gt;['item&lt;sub&gt;id&lt;/sub&gt;'].map(item&lt;sub&gt;id&lt;/sub&gt;&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;mean&lt;/sub&gt;)
&lt;/p&gt;

&lt;p&gt;
all&lt;sub&gt;data&lt;/sub&gt;['item&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;enc&lt;/sub&gt;'].fillna(0.3343, inplace=True) 
&lt;/p&gt;

&lt;p&gt;
encoded&lt;sub&gt;feature&lt;/sub&gt; = all&lt;sub&gt;data&lt;/sub&gt;['item&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;enc&lt;/sub&gt;'].values
print(np.corrcoef(all&lt;sub&gt;data&lt;/sub&gt;['target'].values, encoded&lt;sub&gt;feature&lt;/sub&gt;)[0][1])
&lt;/p&gt;


&lt;p&gt;
'''
     Differently to `.target.mean()` function `transform` 
   will return a dataframe with an index like in `all&lt;sub&gt;data&lt;/sub&gt;`.
   Basically this single line of code is equivalent to the first two lines from of Method 1.
'''
all&lt;sub&gt;data&lt;/sub&gt;['item&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;enc&lt;/sub&gt;'] = all&lt;sub&gt;data.groupby&lt;/sub&gt;('item&lt;sub&gt;id&lt;/sub&gt;')['target'].transform('mean')
&lt;/p&gt;

&lt;p&gt;
all&lt;sub&gt;data&lt;/sub&gt;['item&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;enc&lt;/sub&gt;'].fillna(0.3343, inplace=True) 
&lt;/p&gt;

&lt;p&gt;
encoded&lt;sub&gt;feature&lt;/sub&gt; = all&lt;sub&gt;data&lt;/sub&gt;['item&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;enc&lt;/sub&gt;'].values
print(np.corrcoef(all&lt;sub&gt;data&lt;/sub&gt;['target'].values, encoded&lt;sub&gt;feature&lt;/sub&gt;)[0][1])
&lt;/p&gt;


&lt;p&gt;
grader = Grader()
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all&lt;sub&gt;data&lt;/sub&gt;['target'].values, encoded&lt;sub&gt;feature&lt;/sub&gt;)[0][1]
print(corr)
grader.submit&lt;sub&gt;tag&lt;/sub&gt;('KFold&lt;sub&gt;scheme&lt;/sub&gt;', corr)
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all&lt;sub&gt;data&lt;/sub&gt;['target'].values, encoded&lt;sub&gt;feature&lt;/sub&gt;)[0][1]
print(corr)
grader.submit&lt;sub&gt;tag&lt;/sub&gt;('Leave-one-out&lt;sub&gt;scheme&lt;/sub&gt;', corr)
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all&lt;sub&gt;data&lt;/sub&gt;['target'].values, encoded&lt;sub&gt;feature&lt;/sub&gt;)[0][1]
print(corr)
grader.submit&lt;sub&gt;tag&lt;/sub&gt;('Smoothing&lt;sub&gt;scheme&lt;/sub&gt;', corr)
&lt;/p&gt;


&lt;p&gt;
corr = np.corrcoef(all&lt;sub&gt;data&lt;/sub&gt;['target'].values, encoded&lt;sub&gt;feature&lt;/sub&gt;)[0][1]
print(corr)
grader.submit&lt;sub&gt;tag&lt;/sub&gt;('Expanding&lt;sub&gt;mean&lt;/sub&gt;&lt;sub&gt;scheme&lt;/sub&gt;', corr)
&lt;/p&gt;


&lt;p&gt;
STUDENT&lt;sub&gt;EMAIL&lt;/sub&gt; = # EMAIL HERE
STUDENT&lt;sub&gt;TOKEN&lt;/sub&gt; = # TOKEN HERE
grader.status()
&lt;/p&gt;


&lt;p&gt;
grader.submit(STUDENT&lt;sub&gt;EMAIL&lt;/sub&gt;, STUDENT&lt;sub&gt;TOKEN&lt;/sub&gt;)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>assignment competition encoding</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding-the-competition-data/</guid><pubDate>Mon, 24 Sep 2018 01:50:28 GMT</pubDate></item></channel></rss>