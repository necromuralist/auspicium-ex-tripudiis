<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Kaggle (Posts about notes)</title><link>https://necromuralist.github.io/Kaggle-Competitions/</link><description></description><atom:link href="https://necromuralist.github.io/Kaggle-Competitions/categories/cat_notes.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 04 Oct 2018 01:53:21 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Mean Encoding</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding/#org981d2b2"&gt;Mean Encoding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding/#org8c19d2a"&gt;Regularization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding/#orgdd01022"&gt;Generalizations and Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding/#orgc74a70d"&gt;Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org981d2b2" class="outline-2"&gt;
&lt;h2 id="org981d2b2"&gt;Mean Encoding&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org981d2b2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9189ad0" class="outline-3"&gt;
&lt;h3 id="org9189ad0"&gt;Introduction&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9189ad0"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;also called target encoding and likelihood encoding&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
It is a way to encode a categorical feature. Uses the fraction of times the feature is 1 out of all the times the feature is in the data set (for binary classification).
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf79820e" class="outline-4"&gt;
&lt;h4 id="orgf79820e"&gt;Why does it work?&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf79820e"&gt;
&lt;p&gt;
Unlike regular encoding, which has no real meaning to the labels, mean encoding imposes an ordering. This allows you to reduce your loss while using shorter trees.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0754e80" class="outline-4"&gt;
&lt;h4 id="org0754e80"&gt;How do you calculate it?&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0754e80"&gt;
&lt;p&gt;
There are multiple ways.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Likelihood = \(\frac{count of ones}/{total count}\) = mean(target)&lt;/li&gt;
&lt;li&gt;Weight of evidence = \(\ln\left(\frac{count of ones}{count of zeros}\right)\)&lt;/li&gt;
&lt;li&gt;Count = sum(target) = count of ones&lt;/li&gt;
&lt;li&gt;Diff = count of ones - count of zeros&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5fce97b" class="outline-4"&gt;
&lt;h4 id="org5fce97b"&gt;When does it fail?&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org5fce97b"&gt;
&lt;p&gt;
If you have lots of feature instances with few cases it will tend to overfit.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8c19d2a" class="outline-2"&gt;
&lt;h2 id="org8c19d2a"&gt;Regularization&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8c19d2a"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgda28dd3" class="outline-3"&gt;
&lt;h3 id="orgda28dd3"&gt;Four Types&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgda28dd3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Cross-validation loop inside the training data&lt;/li&gt;
&lt;li&gt;Smoothing&lt;/li&gt;
&lt;li&gt;Adding random noise&lt;/li&gt;
&lt;li&gt;Sorting and calculating the expanding mean&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgde6b1ee" class="outline-3"&gt;
&lt;h3 id="orgde6b1ee"&gt;Cross Validation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgde6b1ee"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Usually 4 or 5 folds are enough&lt;/li&gt;
&lt;li&gt;Need to watch out for extreme cases like leave-out-one (LOO)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Here's an example of this method using sklearn.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;y_train&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;training&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"target"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;
&lt;span class="n"&gt;folds&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StratifiedKFold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y_train&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shuffle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;training_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;validation_index&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;folds&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;x_train&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;training&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iloc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;training_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;x_validation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;training&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iloc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;validation_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="c1"&gt;# 'columns' is a list of columns to encode&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;column&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
	&lt;span class="n"&gt;means&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x_validation&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;column&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x_train&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
	&lt;span class="n"&gt;x_validation&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;coulmn&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"_mean_target"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;means&lt;/span&gt;
    &lt;span class="c1"&gt;# train_new is a dataframe copy we made of the training data&lt;/span&gt;
    &lt;span class="n"&gt;train_new&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iloc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;value_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x_validation&lt;/span&gt;

&lt;span class="n"&gt;global_mean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;training&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"target"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# replace nans with the global mean&lt;/span&gt;
&lt;span class="n"&gt;train_new&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fillna&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;global_mean&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inplace&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org59aad2f" class="outline-3"&gt;
&lt;h3 id="org59aad2f"&gt;Smoothing&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org59aad2f"&gt;
&lt;p&gt;
Use a value \(\alpha\) to control the amount of regularization. This isn't a regularization method in and of itself, you use it with other methods.
&lt;/p&gt;

&lt;p&gt;
\[
\frac{mean(targte) \times n_{rows} + \textit{global mean} \times \alpha}{n_{rows} + \alpha}
\]
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfdf906f" class="outline-3"&gt;
&lt;h3 id="orgfdf906f"&gt;Noise&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfdf906f"&gt;
&lt;p&gt;
Adding noise degrades the quality of the encoding in the training data. This is usually used with &lt;i&gt;leave-one-out&lt;/i&gt; encoding to prevent overfitting. You have to figure out how much noise to add through experimentation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8d98283" class="outline-3"&gt;
&lt;h3 id="org8d98283"&gt;Expanding Mean&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8d98283"&gt;
&lt;p&gt;
This introduces the least amount of leakage from the target variable and doesn't require hyper-parameters for you to tune. The downside is that the encoding quality is irregular. There is a built-in implementation in the &lt;code&gt;CatBoost&lt;/code&gt; library.
&lt;/p&gt;

&lt;p&gt;
Here's a pandas implementation.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cumulative_sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;training&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;column&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="s2"&gt;"target"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cumsum&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;training&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"target"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;cumulative_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;training&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cumcount&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;train_new&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;column&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"_mean_target"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cumulative_sum&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cumulative_count&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6d57dc7" class="outline-3"&gt;
&lt;h3 id="org6d57dc7"&gt;Which one should you use?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6d57dc7"&gt;
&lt;p&gt;
Cross Validation Loops and Expanding Means are the most practical to use.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdd01022" class="outline-2"&gt;
&lt;h2 id="orgdd01022"&gt;Generalizations and Extensions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdd01022"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org187f583" class="outline-3"&gt;
&lt;h3 id="org187f583"&gt;Regression and Multiclass&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc74a70d" class="outline-2"&gt;
&lt;h2 id="orgc74a70d"&gt;Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc74a70d"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb189648" class="outline-3"&gt;
&lt;h3 id="orgb189648"&gt;Advantages&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb189648"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Compact transformation of categorical variables&lt;/li&gt;
&lt;li&gt;Powerful basis for feature engineering&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org388894b" class="outline-3"&gt;
&lt;h3 id="org388894b"&gt;Disadvantages&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org388894b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Needs careful validation, it's easy to overfit&lt;/li&gt;
&lt;li&gt;Only certain data sets will show a significant improvement from using it&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes encoding</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/mean-encoding/</guid><pubDate>Mon, 24 Sep 2018 00:56:27 GMT</pubDate></item><item><title>Optimizing Classification Metrics</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/optimizing-classification-metrics/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org9dc917b" class="outline-2"&gt;
&lt;h2 id="org9dc917b"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9dc917b"&gt;
&lt;p&gt;
The &lt;i&gt;target metric&lt;/i&gt; is what the competition scores you on, but it isn't always the easiest metric to tune your model on. Sometimes you need to pick and &lt;i&gt;optimization metric&lt;/i&gt; to tune your model that isn't exactly the same but works well enough.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb733e2f" class="outline-2"&gt;
&lt;h2 id="orgb733e2f"&gt;LogLoss&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb733e2f"&gt;
&lt;p&gt;
To optimize log-loss you just have to match it to the right model.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Tree Based: XGBoost, LightGBM&lt;/li&gt;
&lt;li&gt;Linear: sklearn.&amp;lt;something&amp;gt;Regression, sklearn.SGDRegressor, Vowpal Wabbit&lt;/li&gt;
&lt;li&gt;Neural Nets: PyTorch, Keras, Tensorflow, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Random Forests turn out to do poorly with Log Loss.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org89db9fa" class="outline-3"&gt;
&lt;h3 id="org89db9fa"&gt;Probability Calibration&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org89db9fa"&gt;
&lt;p&gt;
If you take all the rows with the same score, then the fraction of them that have a class of 1 should match the score (so if they all have a score of 0.8, then 80% of them should be 1 and 20% should be 0). If the fraction is off, then you need to calibrate the probabilities. To do this take your model and then send its outputs to a model that does better with Log Loss. So if you want to use a Random Forest, you would train your model using AUC as the metric then use the predictions to train another model like a neural net and have it use Log Loss as the metric.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org336306c" class="outline-4"&gt;
&lt;h4 id="org336306c"&gt;Platt Scaling&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org336306c"&gt;
&lt;p&gt;
Fit a Logistic Regression to your predictions
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org636f8a8" class="outline-4"&gt;
&lt;h4 id="org636f8a8"&gt;Isotonic Regression&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org636f8a8"&gt;
&lt;p&gt;
Fit an Isotonic Regression to your predictions
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf6afab3" class="outline-4"&gt;
&lt;h4 id="orgf6afab3"&gt;Stacking&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf6afab3"&gt;
&lt;p&gt;
Fit XGBoost or a neural net to your predictions
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb75ed53" class="outline-2"&gt;
&lt;h2 id="orgb75ed53"&gt;Accuracy&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb75ed53"&gt;
&lt;p&gt;
Accuracy is a difficult metric to optimize because it isn't differentiable. To optimize the accuracy metric you need to use a different metric (a proxy metric) like log-loss and then tune the threshold.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org87b89a4" class="outline-2"&gt;
&lt;h2 id="org87b89a4"&gt;Area Under the Curve (AUC)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org87b89a4"&gt;
&lt;p&gt;
Some models work with it so if you can choose one of these models.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Tree-Based: XGBoost, LightGBM&lt;/li&gt;
&lt;li&gt;Linear: (don't use)&lt;/li&gt;
&lt;li&gt;Neural Nets: PyTorch, Keras, TensorFlow (but not by default)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In practice you can optimize the model to log-loss.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb8d2c5a" class="outline-2"&gt;
&lt;h2 id="orgb8d2c5a"&gt;Quadratic Weighted Kappa&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb8d2c5a"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Optimize on the Mean Squared Error then optimize the thresholds.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org324445f" class="outline-2"&gt;
&lt;h2 id="org324445f"&gt;Other Sources&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org324445f"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orged729be" class="outline-3"&gt;
&lt;h3 id="orged729be"&gt;Classification&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orged729be"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://queirozf.com/entries/evaluation-metrics-for-classification-quick-examples-references"&gt;Evaluation Metrics for Classification Problems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.garysieling.com/blog/sklearn-gini-vs-entropy-criteria"&gt;Descision Trees: &lt;i&gt;Gini&lt;/i&gt; vs &lt;i&gt;Entropy&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.navan.name/roc/"&gt;Understanding ROC Curves&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org91978e5" class="outline-3"&gt;
&lt;h3 id="org91978e5"&gt;Ranking&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org91978e5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://icml.cc/2015/wp-content/uploads/2015/06/icml_ranking.pdf"&gt;Learning to Rank Using Gradient Descent&lt;/a&gt; - source of pairwise AUC optimization&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MSR-TR-2010-82.pdf"&gt;From RankNet to LambdaRank&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sourceforge.net/p/lemur/wiki/RankLib/"&gt;RankLib (implementation of the two previous papers&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wellecks.wordpress.com/2015/01/15/learning-to-rank-overview/"&gt;Learning to Rank Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org82e5d75" class="outline-3"&gt;
&lt;h3 id="org82e5d75"&gt;Clustering&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org82e5d75"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://nlp.uned.es/docs/amigo2007a.pdf"&gt;Comparison of clustering metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgce36bdf" class="outline-2"&gt;
&lt;h2 id="orgce36bdf"&gt;Practice Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgce36bdf"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;What would be a logloss value for a binary classification task if we use a constant predictor \(f(x)=0.5\)? Round to two decimal places.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
-0.69 (marked as wrong)
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;What is the best constant predictor for the Mean Absolute Error?
&lt;ul class="org-ul"&gt;
&lt;li&gt;Target 50th percentile, Target median&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;The best constant predictor for the Mean Squared Error is:

&lt;ul class="org-ul"&gt;
&lt;li&gt;Target Mean, average of the target vector&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The best Constant prediction for the Area Under the Curve is:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Any constant will lead to the same AUC value (should also mark target median, target mean, 1, 0.5, Target Mean divided by target variance - since any constant will lead to the same value, they are all the same)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Suppose the target metric is \(r^2\), what optimization loss should we use for our models?
&lt;ul class="org-ul"&gt;
&lt;li&gt;RMSE, MSE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Calculate the AUC for these predictions:&lt;/li&gt;
&lt;/ol&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;target&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;prediction&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;0.39&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;td class="org-right"&gt;0.52&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;0.91&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;0.85&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;0.49&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;td class="org-right"&gt;0.02&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;td class="org-right"&gt;0.44&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# from pypi
from sklearn.metrics import roc_auc_score
y_true = [1,0,1,1,1,0,0]
y_score = [0.39,0.52,0.91,0.85,0.49,0.02,0.44]
print(roc_auc_score(y_true, y_score))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0.75

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8885982" class="outline-2"&gt;
&lt;h2 id="org8885982"&gt;Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8885982"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org24e1008" class="outline-3"&gt;
&lt;h3 id="org24e1008"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org24e1008"&gt;
&lt;p&gt;
Suppose we solve a binary classification task and our solution is scored with Log Loss. What predictions are preferable if all the true target values are 0?
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; (0.4, 0.5, 0.5, 0.6) - marked wrong&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; (0.5, 0.5, 0.5, 0.5)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; (0, 0, 0, 1)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;import numpy
one = numpy.array([0.4, 0.5, 0.5, 0.6])
two = numpy.array([0.5, 0.5, 0.5, 0.5])
three = numpy.array([0, 0, 0, 1])

for guess in (one, two, three):
    print(sum(-numpy.log(1 - guess))/len(guess))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0.7033526791900091
0.6931471805599453
inf
/home/hades/.virtualenvs/machine-learning-studies/lib/python3.6/site-packages/ipykernel_launcher.py:7: RuntimeWarning: divide by zero encountered in log
  import sys

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7f5bef6" class="outline-3"&gt;
&lt;h3 id="org7f5bef6"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7f5bef6"&gt;
&lt;p&gt;
Suppose we solve a regression task and we optimize MSE. If we manage to lower MSE loss on either the training set or the test set, how would this affect the Pearson Correlation coefficient between the target vector and the predictions on the same set.
&lt;/p&gt;

&lt;p&gt;
The correlation will also be lowered.
The correlation will not change.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; The correlation will become larger. - marked wrong&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Any behavior is possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb4de534" class="outline-3"&gt;
&lt;h3 id="orgb4de534"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb4de534"&gt;
&lt;p&gt;
What would be a best constant prediction for a multi-class classification with four classes? The solution is scored with multi-class Log Loss. The number of objects in each class in the training set is 18, 3, 15, 24.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Guess one: 0,1,2,3&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;counts = numpy.array([18, 3, 15, 24])
print(counts/counts.sum())
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
[0.3  0.05 0.25 0.4 ]

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orged3cab1" class="outline-3"&gt;
&lt;h3 id="orged3cab1"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orged3cab1"&gt;
&lt;p&gt;
What is the best constant predictor for the r-squared metric?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;one minus the target mean, target mean (0 points)&lt;/li&gt;
&lt;li&gt;0.5 (0 points)&lt;/li&gt;
&lt;li&gt;Target Mean (same as the MSE)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3852398" class="outline-3"&gt;
&lt;h3 id="org3852398"&gt;Five&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3852398"&gt;
&lt;p&gt;
Select the Correct statements
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Optimization loss can be the same as the target metric&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Optimization loss can be different from the target metric&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Optimization loss is always different from the target metric&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Optimization loss is always the same as the target metric&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfea6e6f" class="outline-3"&gt;
&lt;h3 id="orgfea6e6f"&gt;Six&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfea6e6f"&gt;
&lt;p&gt;
Suppose the target metric is &lt;b&gt;M1&lt;/b&gt; and the optimization loss is &lt;b&gt;M2&lt;/b&gt;. We train a model and monitor its quality on a holdout set using the metrics &lt;b&gt;M1&lt;/b&gt; and &lt;b&gt;M2&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Select the correct statement:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; If the best &lt;b&gt;M1&lt;/b&gt; score is attained at iteration &lt;i&gt;N&lt;/i&gt;, then the best &lt;b&gt;M2&lt;/b&gt; score is always attained after the n-th iteration.&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; If the best &lt;b&gt;M1&lt;/b&gt; score is attained at iteration &lt;i&gt;N&lt;/i&gt;, then the best &lt;b&gt;M2&lt;/b&gt; score is always attained before the n-th iteration.&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; If the best &lt;b&gt;M1&lt;/b&gt; score is attained at iteration &lt;i&gt;N&lt;/i&gt;, then the best &lt;b&gt;M2&lt;/b&gt; score is always attained at the n-th iteration.&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; There is no definite relation between the best iterations for the &lt;b&gt;M1&lt;/b&gt; score and the &lt;b&gt;M2&lt;/b&gt; score.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes metrics classification</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/optimizing-classification-metrics/</guid><pubDate>Sun, 23 Sep 2018 22:10:09 GMT</pubDate></item><item><title>Optimizing Metrics</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/optimizing-metrics/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/optimizing-metrics/#orge68c5a4"&gt;Mean Squared Error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/optimizing-metrics/#org6ac307e"&gt;Mean Absolute Error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/optimizing-metrics/#org47aa5a2"&gt;Mean Squared Probability Error and Mean Absolute Probability Error&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge68c5a4" class="outline-2"&gt;
&lt;h2 id="orge68c5a4"&gt;Mean Squared Error&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge68c5a4"&gt;
&lt;p&gt;
This works, just use it as the optimization metric.
Sometimes this will be called &lt;i&gt;L2&lt;/i&gt; loss.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6ac307e" class="outline-2"&gt;
&lt;h2 id="org6ac307e"&gt;Mean Absolute Error&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6ac307e"&gt;
&lt;p&gt;
Once again, this works so just use it.
Sometimes this will be called &lt;i&gt;L1&lt;/i&gt; loss - it isn't as widely implemented.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org47aa5a2" class="outline-2"&gt;
&lt;h2 id="org47aa5a2"&gt;Mean Squared Probability Error and Mean Absolute Probability Error&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org47aa5a2"&gt;
&lt;p&gt;
Some libraries will let you use them as `sample_weights`
Some libraries (like sklearn) will require you to re-sample the data &lt;code&gt;df.sample(weights=sample_weights)&lt;/code&gt;
Once you re-sample the data you can use any model that optimizes MSE or MAE
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes metrics</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/optimizing-metrics/</guid><pubDate>Sat, 22 Sep 2018 23:26:49 GMT</pubDate></item><item><title>General Approaches to Metrics Optimization</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/general-approaches-to-metrics-optimization/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-orgb3d5141" class="outline-2"&gt;
&lt;h2 id="orgb3d5141"&gt;What do we mean by &lt;i&gt;loss&lt;/i&gt; and &lt;i&gt;metric&lt;/i&gt;?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb3d5141"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the &lt;code&gt;metric&lt;/code&gt; is what we &lt;i&gt;want&lt;/i&gt; to optimize - but we sometimes don't really know how to optimize this, this is just how we evaluate the model in the end&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loss&lt;/code&gt; is what the model actually optimizes&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3cbfad2" class="outline-2"&gt;
&lt;h2 id="org3cbfad2"&gt;How do you optimize the target metric?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3cbfad2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;In some cases you can just use them (e.g. &lt;i&gt;MSE&lt;/i&gt;, &lt;i&gt;logloss&lt;/i&gt;)&lt;/li&gt;
&lt;li&gt;In some cases you need to do a preprocessing training step with another metric
(e.g. &lt;i&gt;MSPE&lt;/i&gt;, &lt;i&gt;MAPE&lt;/i&gt;, &lt;i&gt;RMSLE&lt;/i&gt;)&lt;/li&gt;
&lt;li&gt;In osme cases you need to train on a different metric and then use post-processing during the prediction step&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9202920" class="outline-2"&gt;
&lt;h2 id="org9202920"&gt;Early Stopping&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9202920"&gt;
&lt;p&gt;
To work around these problems, use two metrics &lt;i&gt;m1&lt;/i&gt; and &lt;i&gt;m2&lt;/i&gt; and optimize on metric &lt;i&gt;m1&lt;/i&gt; while monitoring &lt;i&gt;m2&lt;/i&gt;, then stop when &lt;i&gt;m2&lt;/i&gt; is optimal.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes metrics</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/general-approaches-to-metrics-optimization/</guid><pubDate>Sat, 22 Sep 2018 23:04:35 GMT</pubDate></item><item><title>Classification Metrics</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/classification-metrics/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/classification-metrics/#orge7d1869"&gt;Accuracy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/classification-metrics/#orgd89e10e"&gt;Logarithmic Loss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/classification-metrics/#org2facf85"&gt;Area Under the ROC Curve (AUC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/classification-metrics/#orgbb68eb5"&gt;Quadratic Weighted Kappa (Cohen's Kappa)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge7d1869" class="outline-2"&gt;
&lt;h2 id="orge7d1869"&gt;Accuracy&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge7d1869"&gt;
&lt;p&gt;
This metric measures how frequently our model is correct.
&lt;/p&gt;

&lt;p&gt;
\[
Accuracy = \frac{1}{N} \sum_{i=1}^N \left[\hat{y}_i = y_i \right]
\]
&lt;/p&gt;

&lt;p&gt;
If you were to make a model that just predicted a constant value, the best value would be the most common one. This points out the fact that a severely imbalanced data set can have a model with high accuracy that isn't actually a particularly good one (it just predicts the most frequent classification all the time).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd89e10e" class="outline-2"&gt;
&lt;h2 id="orgd89e10e"&gt;Logarithmic Loss&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd89e10e"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf72ee7b" class="outline-3"&gt;
&lt;h3 id="orgf72ee7b"&gt;Binary Version&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf72ee7b"&gt;
&lt;p&gt;
\[
LogLoss = -\frac{1}{N} \sum_{i=1}^N y_i \log (\hat{y}_i) + (1 - y_i) \log (1 - \hat{y}_i)
\]
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga7bced8" class="outline-3"&gt;
&lt;h3 id="orga7bced8"&gt;Multiclass Version&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga7bced8"&gt;
&lt;p&gt;
\[
LogLoss = -\frac{1}{N} \sum_{i=1}^N \sum_{i=1}^L y_{il} \log (\hat{y}_{il})
\]
&lt;/p&gt;

&lt;p&gt;
Where &lt;i&gt;L&lt;/i&gt; is the number of classes.
&lt;/p&gt;

&lt;p&gt;
When compared to accuracy, accuracy is linear over the amount of error, while logarithmic loss grows exponentially the more error there is, so it more severely penalizes your model the more wrong it is.
&lt;/p&gt;

&lt;p&gt;
If you wanted to make a constant prediction, the best constant is to set the constant(s) to the frequencies for each class.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2facf85" class="outline-2"&gt;
&lt;h2 id="org2facf85"&gt;Area Under the ROC Curve (AUC)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2facf85"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;only for binary classification&lt;/li&gt;
&lt;li&gt;depends only on the ordering of the predictions, not the absolute values&lt;/li&gt;
&lt;li&gt;can be thought of as the area under the curve or the ordering of pairs&lt;/li&gt;
&lt;li&gt;The baseline score is 0.5&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbb68eb5" class="outline-2"&gt;
&lt;h2 id="orgbb68eb5"&gt;Quadratic Weighted Kappa (Cohen's Kappa)&lt;/h2&gt;
&lt;/div&gt;</description><category>metrics classification notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/classification-metrics/</guid><pubDate>Sat, 22 Sep 2018 22:35:29 GMT</pubDate></item><item><title>Metrics Optimization 2</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics-optimization-2/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org19e5026" class="outline-2"&gt;
&lt;h2 id="org19e5026"&gt;(R)MSPE, MAPE, and (R)MSLE&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org19e5026"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1cf2c17" class="outline-3"&gt;
&lt;h3 id="org1cf2c17"&gt;An Off-By-One Example&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1cf2c17"&gt;
&lt;p&gt;
Suppose we are predicting sales for two shops and the two shops have different sales volumes but our predictions for both cases are off by one. In this case our Mean-Squared-Error (MSE) might be the same, but they have a different significance.
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;Shop&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Actual&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Predicted&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;MSE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;9&lt;/td&gt;
&lt;td class="org-left"&gt;10&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;999&lt;/td&gt;
&lt;td class="org-left"&gt;1,000&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc785c87" class="outline-2"&gt;
&lt;h2 id="orgc785c87"&gt;Root Mean Squared Percentage Error and Mean Absolute Percentage Error&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc785c87"&gt;
&lt;p&gt;
The MSE and Mean-Absolute-Error (MAE) are absolute errors which don't take into account how significant the error is. There are two relative errors,  Mean-Squared-Percentage-Error (MSPE) and Mean-Absolute-Percentage-Error (MAPE) that divide each error term by the actual value to give you a realive error instead of an absolute error.
&lt;/p&gt;

&lt;p&gt;
\[
MSPE = \frac{1}{N} \sum_{i=1}^n \left( \frac{y_i - \hat{y}}{y_i}\right)^2
\]
&lt;/p&gt;

&lt;p&gt;
\[
MAPE = \frac{1}{N} \sum_{i=1}^n \left| \frac{y_i - \hat{y}}{y_i}\right|
\]
&lt;/p&gt;

&lt;p&gt;
The MAPE will be inversely proportional to its target and the MSPE will be inversely proportional to the square of the target.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdaad713" class="outline-3"&gt;
&lt;h3 id="orgdaad713"&gt;Optimal Constant Predictions&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdaad713"&gt;
&lt;p&gt;
The best constant prediction you can make when using the Mean Squared Error is to predict the mean of the target values. The best prediction you can make for the MSPE is to take a weighted mean of the target values. The best constant prediction you can make for the Mean Absolute Percentage Error is the weighted median.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org35ea739" class="outline-2"&gt;
&lt;h2 id="org35ea739"&gt;Root Mean Squared Logarithmic Error (MSLE)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org35ea739"&gt;
&lt;p&gt;
\[
MSLE = \sqrt{\frac{1}{N}\sum_{i=1}^N (\log (y_i + 1) - \log(\hat{y}_i + 1))^2}\\
= \sqrt{MSE(\log(y_i + 1), \log(\hat{y}_i + 1))}
\]
&lt;/p&gt;

&lt;p&gt;
You add a 1 to each term to prevent you from trying to take the &lt;i&gt;log&lt;/i&gt; of 0, which is undefined. The RMSLE is biased toward predictions that are higher than the actual values rather than lower.
&lt;/p&gt;

&lt;p&gt;
These are the best constant predictions you can make for the competition data set.
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Metric&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Constant&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;MSE&lt;/td&gt;
&lt;td class="org-right"&gt;11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;RMSLE&lt;/td&gt;
&lt;td class="org-right"&gt;9.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;MAE&lt;/td&gt;
&lt;td class="org-right"&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;MSPE&lt;/td&gt;
&lt;td class="org-right"&gt;6.6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;MAPE&lt;/td&gt;
&lt;td class="org-right"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes metrics</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics-optimization-2/</guid><pubDate>Wed, 19 Sep 2018 15:04:33 GMT</pubDate></item><item><title>Metrics</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/#orga4dac78"&gt;About Metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/#org1c58ab3"&gt;The Most Common Metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga4dac78" class="outline-2"&gt;
&lt;h2 id="orga4dac78"&gt;About Metrics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga4dac78"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3f23f45" class="outline-3"&gt;
&lt;h3 id="org3f23f45"&gt;What are metrics?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3f23f45"&gt;
&lt;p&gt;
Metrics are numeric values that you are trying to optimize - they are how your model is graded.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge0acf78" class="outline-3"&gt;
&lt;h3 id="orge0acf78"&gt;Why are there so many metrics?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge0acf78"&gt;
&lt;p&gt;
Each metric can tell you something different, so what metric you need depends on the problem you are trying to solve. For competitions, it is sometimes possible to do metrics probing just like you can sometimes do leaderboard probing to find peculiarities created by the chosen metric.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1c58ab3" class="outline-2"&gt;
&lt;h2 id="org1c58ab3"&gt;The Most Common Metrics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1c58ab3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd104bd3" class="outline-3"&gt;
&lt;h3 id="orgd104bd3"&gt;Regression&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd104bd3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdb9a946" class="outline-4"&gt;
&lt;h4 id="orgdb9a946"&gt;Mean Squared Error&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgdb9a946"&gt;
&lt;p&gt;
This is the average of the square of the errors.
\[
MSE = \frac{1}{N}
\]
&lt;/p&gt;

&lt;p&gt;
The target mean value is the best constant prediction.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5248025" class="outline-4"&gt;
&lt;h4 id="org5248025"&gt;Root Mean Squared Error&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org5248025"&gt;
&lt;p&gt;
This is the square root of the mean squared error.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;minimizing the RMSE is also minimizes the MSE&lt;/li&gt;
&lt;li&gt;RMSE is more intuitive&lt;/li&gt;
&lt;li&gt;They can differ when used by gradient-based models&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf96fba4" class="outline-4"&gt;
&lt;h4 id="orgf96fba4"&gt;R-squared&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf96fba4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Optimizing r-squared is equivalent to optimizing MSE&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge8653a1" class="outline-4"&gt;
&lt;h4 id="orge8653a1"&gt;Mean Absolute Error&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge8653a1"&gt;
&lt;p&gt;
This is more common when you are explaining it to a non-statistician. It is also more robust. Mathematically, it isn't something that you can calculate the derivate for.
&lt;/p&gt;

&lt;p&gt;
The target median is the best constant prediction.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6b02d49" class="outline-4"&gt;
&lt;h4 id="org6b02d49"&gt;MAE vs MSE&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6b02d49"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Outliers: use MAE&lt;/li&gt;
&lt;li&gt;Unexpected Values that we should still care about (not true outliers (mistakes), just rare): use MSE&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>metrics notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/</guid><pubDate>Tue, 18 Sep 2018 04:49:35 GMT</pubDate></item><item><title>Data Leaks</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/data-leaks/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-orgc295f47" class="outline-2"&gt;
&lt;h2 id="orgc295f47"&gt;What are data leaks?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc295f47"&gt;
&lt;p&gt;
&lt;i&gt;Data Leaks&lt;/i&gt; are unexpected errors that expose extra information that wouldn't be available in production.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc470d9c" class="outline-2"&gt;
&lt;h2 id="orgc470d9c"&gt;Time Series&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc470d9c"&gt;
&lt;p&gt;
Check if there are points in the training set that are in the future with regard to the test set.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf5b8f55" class="outline-2"&gt;
&lt;h2 id="orgf5b8f55"&gt;Unexpected Information&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf5b8f55"&gt;
&lt;p&gt;
Sometimes what looks like a non-predictive feature might prove to be useful because of the way the data-set was created.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;ID&lt;/li&gt;
&lt;li&gt;Row Order&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org22ee9c5" class="outline-2"&gt;
&lt;h2 id="org22ee9c5"&gt;Leaderboard Probing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org22ee9c5"&gt;
&lt;p&gt;
This is a method to look for dataleaks based on the leader board.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3d1f88c" class="outline-2"&gt;
&lt;h2 id="org3d1f88c"&gt;Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3d1f88c"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8a8b53f" class="outline-3"&gt;
&lt;h3 id="org8a8b53f"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8a8b53f"&gt;
&lt;p&gt;
Suppose that you have a credit scoring task where you have to create a machine learning model that approximates expert evaluation of an individual's creditworthiness. Which of the following can potentially be a data leakage?
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; An ID of a data point (row) in the train set corellates with the target variable (the data wasn't shuffled, this information won't work in a real-world scenario)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The first half of the data points in the train set have a score of 0 while the second half has scores &amp;gt; 0. (same as above)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Among he features you have a &lt;code&gt;company_id&lt;/code&gt;, an identifier of a company where this person works. It turns out that this feature is important and adding it to your model improves your score. (this is a normal feature, the fact that it improves your score just means it's an important feature)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org016f80b" class="outline-3"&gt;
&lt;h3 id="org016f80b"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org016f80b"&gt;
&lt;p&gt;
What is the most foolproof way to set up a time-series competition?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Split, train, public and private parts of the data by time. Remove all features except IDs from the test set so that participants will generate all the features based on the past and join them themselves. (you need to remove all features tfrom the test set to guarantee there isn't a data-leakage)&lt;/li&gt;

&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Make a time based split for train/test and a random split for publit/private. (this is vulnerable to leaderboard probing)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; split public and private by time, remove time from the test set. (it is possible to reverse engineer the time-ordering and exploit future-peeking)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0fb70f2" class="outline-3"&gt;
&lt;h3 id="org0fb70f2"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0fb70f2"&gt;
&lt;p&gt;
Suppose you have a binary feature classification task and it is evaluated by the logloss metric. You know that there are 10,000 entries in the public chunk of the test set and that a constant prediction of 0.3 gets a score of 1.01. The mean of the target variable in the training set is 0.44. What is the mean of the target variable in the public part  of the test data (up to 4 decimal places.)
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;0.44 (wrong)&lt;/li&gt;
&lt;li&gt;0.132 (wrong)&lt;/li&gt;
&lt;li&gt;1.33 (wrong)&lt;/li&gt;
&lt;li&gt;0.7712&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
\[
\frac{N_1}{N} = \frac{-L - \ln (1-C)}{\ln C - \ln (1 - C)}\\
= 0.7712\\
\]
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org51ae2c6" class="outline-3"&gt;
&lt;h3 id="org51ae2c6"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org51ae2c6"&gt;
&lt;p&gt;
Suppose you are solving an image classification task, what is the classification of the logo for this course?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Angry robot (wrong - should be a number)&lt;/li&gt;
&lt;li&gt;1 (wrong - check image name)&lt;/li&gt;
&lt;li&gt;3 (the URL for the image had the answer in it)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>dataleaks notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/data-leaks/</guid><pubDate>Sat, 08 Sep 2018 23:11:07 GMT</pubDate></item><item><title>Validation</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/validation/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org22f02cf"&gt;Validation and Overfitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org053f296"&gt;Three Main Methods of Splitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org93d900d"&gt;Stratification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org069e155"&gt;Data Splitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#orgc0e900d"&gt;Problems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org4c3fbf9"&gt;Practice Quiz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#orgd762960"&gt;Quiz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org81acef0"&gt;Links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org22f02cf" class="outline-2"&gt;
&lt;h2 id="org22f02cf"&gt;Validation and Overfitting&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org22f02cf"&gt;
&lt;p&gt;
To prevent your model from overfitting to the training set, you can hold out some of the training set and use it to validate the model after it has been fit to the rest of the training set.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Underfitting: your model isn't complex enough to capture the data&lt;/li&gt;
&lt;li&gt;Overfitting: your model is too complex and it is modelling noise in the data&lt;/li&gt;
&lt;li&gt;In a competition, if your model does well on the validation set but not on the test set, then it probably overfit the data you had&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org053f296" class="outline-2"&gt;
&lt;h2 id="org053f296"&gt;Three Main Methods of Splitting&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org053f296"&gt;
&lt;p&gt;
These are methods for splitting your training set into training and validation sets. Once you have a model, re-train it over the entire training set before applying it to the test set.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge858c0c" class="outline-3"&gt;
&lt;h3 id="orge858c0c"&gt;Holdout&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge858c0c"&gt;
&lt;p&gt;
This method just splits the data into one training and one validation set.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.ShuffleSplit.html"&gt;sklearn.model_selection.ShuffleSplit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngroups=1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd2d4371" class="outline-3"&gt;
&lt;h3 id="orgd2d4371"&gt;K-Fold&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd2d4371"&gt;
&lt;p&gt;
Make &lt;i&gt;k&lt;/i&gt; splits of the training set, then use each of the validation sets while training on all the data not in the validation set. This differs from doing holdout k-times since we guarantee that the validation sets don't overlap. Uses the average score for the k-folds.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html"&gt;sklearn.model_selection.KFold&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org36c6407" class="outline-3"&gt;
&lt;h3 id="org36c6407"&gt;Leave One Out&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org36c6407"&gt;
&lt;p&gt;
This is like k-folds except we always use a validation set of size 1 - so we are iterating over each point in the data set and using it as the training set. This can be useful if the data set is small.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.LeaveOneOut.html"&gt;sklearn.model_selection.LeaveOneOut&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org93d900d" class="outline-2"&gt;
&lt;h2 id="org93d900d"&gt;Stratification&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org93d900d"&gt;
&lt;p&gt;
Sometimes you need to make sure your validation sets have the same distribution as your set as a whole.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;small datasets&lt;/li&gt;
&lt;li&gt;unbalanced datasects&lt;/li&gt;
&lt;li&gt;multiclass classification&lt;/li&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedShuffleSplit.html"&gt;StratifieShuffleSplit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org069e155" class="outline-2"&gt;
&lt;h2 id="org069e155"&gt;Data Splitting&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org069e155"&gt;
&lt;p&gt;
If you have time-based data, there's two ways to split the training data - randomly within the entire timespan, or put the first part of the data in the training set and put the second part of the data in the validation set. If the test-set is a time that is beyond the training data, then using the time-based split will produce a model that is better for the testing data.
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Row-wise split
This is the most common case, where rows are randomly chosen from the training data. This assumes the rows are independent.&lt;/li&gt;
&lt;li&gt;Time-wise split
This is the case where you are predicting future values of a time-series. In this case, the further back in time a row is, the less like the future value it is.&lt;/li&gt;
&lt;li&gt;By-ID
In this case several rows map to one ID, and the ID maps to a target. For example, you might have several x-rays for one patient that map to one diagnosis.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
The main point of this is that you want to set up your validation set to match the way the train-test sets were split.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc0e900d" class="outline-2"&gt;
&lt;h2 id="orgc0e900d"&gt;Problems&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc0e900d"&gt;
&lt;p&gt;
The point of doing the training-validation split is that you think the validation set(s) will approximate the test set. But what if that's not true?
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgedb54c7" class="outline-3"&gt;
&lt;h3 id="orgedb54c7"&gt;Causes of score differences&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgedb54c7"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Too little data&lt;/li&gt;
&lt;li&gt;The data is too diverse and inconsistent&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6dcbb3d" class="outline-3"&gt;
&lt;h3 id="org6dcbb3d"&gt;Submission Differs from Validation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6dcbb3d"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Even K-fold validation has variation (check that the standard deviation across folds encompasses the leaderboard values)&lt;/li&gt;
&lt;li&gt;Too little data on leaderboard (nothing you can do)&lt;/li&gt;
&lt;li&gt;Train and test are from different distributions&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4c3fbf9" class="outline-2"&gt;
&lt;h2 id="org4c3fbf9"&gt;Practice Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4c3fbf9"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org96b8ead" class="outline-3"&gt;
&lt;h3 id="org96b8ead"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org96b8ead"&gt;
&lt;p&gt;
We did a K-Fold cross validation on a huge dataset and noticed that scores on each fold are roughly the same. Which validation type is of most practical use?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; K-Fold&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Holdout&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Leave one out&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3b5030d" class="outline-3"&gt;
&lt;h3 id="org3b5030d"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3b5030d"&gt;
&lt;p&gt;
We did a K-fold cross validation on a medium sized dataset and noticed that the validation scores varied widely. Which validation type is the most practical to use?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Leave One Out&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; K Fold&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Houldout&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga16d003" class="outline-3"&gt;
&lt;h3 id="orga16d003"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga16d003"&gt;
&lt;p&gt;
The features we generate depend on the train-test split. True or False?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; True&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; False&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbf8dc24" class="outline-3"&gt;
&lt;h3 id="orgbf8dc24"&gt;Which of these can indicate an expected leaderboard shuffle in a competition?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgbf8dc24"&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Little training and/or testing data&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Most of the competitors have similar scores&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Different public/private data or target distributions&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd762960" class="outline-2"&gt;
&lt;h2 id="orgd762960"&gt;Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd762960"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0f99d6e" class="outline-3"&gt;
&lt;h3 id="org0f99d6e"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0f99d6e"&gt;
&lt;p&gt;
Select the true statements.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; A performance increase on a fixed cross-validation split guarantees a performance increase on any cross-validation split. (You might be overfitting. You should change the splits to check for overfitting.)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The logic behind the validation split should mimic the logic behind the train-test split (this is the main rule for making a reliable validation)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Underfitting refers to not capturing enough patterns in the data&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; We use validation to estimate the quality of our model (this is the main purpose of validation)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; The model that does on the validation set is guaranteed to do the best on the test set. (The test and validation sets might have different distributions, in which case the validation won't predict the test set score)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd32fb63" class="outline-3"&gt;
&lt;h3 id="orgd32fb63"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd32fb63"&gt;
&lt;p&gt;
Kaggle usually allows you to submit two final submissions that will be checked against the private leader board. One common practice is to use a model that did the best on the validation scores and another that did best on the public leader board. What is the logic behind using these two models?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; People rarely overfit the public leaderboard. You almost always have a lot of test data and it is hard to overfit.&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Validation is rarely valid in competitions. You must account for the case where validation worked and where it didn't.&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The test set may have a different distribution than the target data. If this is true, then the model that did better on the public leaderboard will do better. If not, then the model that did better in validation will do better.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgfe98d1d" class="outline-3"&gt;
&lt;h3 id="orgfe98d1d"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfe98d1d"&gt;
&lt;p&gt;
Suppose we have a dataset of marketing campaigns. Each campain runs for a few weeks and for each campaign our target is the number of new customers. A row in the dataset looks like this:
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Campaign ID, Date, {some features},Number of New Customers&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
The dataset contains multiple campaigns where the training set has the dates at the start of each campaign and the test set has the dates at the end of each campaign. Which train/test split should you use?
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Random Split&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Combined Split (Each train and test set are divided by a date and the date might be for different campaigns, so it is a combination of campaign ID and date)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; ID-based split (wrong)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Time-based split (wrong)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc3bf35f" class="outline-3"&gt;
&lt;h3 id="orgc3bf35f"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc3bf35f"&gt;
&lt;p&gt;
Which of the following can you usually identify without the leaderboard?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Different scores/optimal parameters between different folds (this is determined during validation)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Train and test target data are from different distributions (You would need the test target values to figure this out, which you won't have)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The public leaderboard score will be unreliable because there is too little data (you can check this by making the size of the folds match the size of the public test set and see the variability)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The train and test data are from different distributions (you can often figure this out during Exploratory Data Analysis)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org81acef0" class="outline-2"&gt;
&lt;h2 id="org81acef0"&gt;Links&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org81acef0"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/cross_validation.html"&gt;Cross-validation in sklearn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chioka.in/how-to-select-your-final-models-in-a-kaggle-competitio/"&gt;Model Selection for Kaggle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes validation</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/validation/</guid><pubDate>Tue, 04 Sep 2018 15:01:59 GMT</pubDate></item><item><title>Springleaf Competition</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/springleaf-competition/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-orgfea27b7" class="outline-2"&gt;
&lt;h2 id="orgfea27b7"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfea27b7"&gt;
&lt;p&gt;
The data comes from the &lt;a href="https://www.kaggle.com/c/springleaf-marketing-response"&gt;Springleaf Marketing Response&lt;/a&gt; competition. Springleaf makes personal loans and wanted to be able to predict who would respond to their direct mail offers. Submissions are evaluated on the area under the ROC curve between the predicted probability and the target. The submission file should have an ID and the probability that the person would respond.
&lt;/p&gt;

&lt;pre class="example"&gt;
ID,target
1,0.35
3,0.01
6,0.93333
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>example competition notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/springleaf-competition/</guid><pubDate>Tue, 04 Sep 2018 13:35:25 GMT</pubDate></item></channel></rss>