<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Kaggle (Posts about notes)</title><link>https://necromuralist.github.io/Kaggle-Competitions/</link><description></description><atom:link href="https://necromuralist.github.io/Kaggle-Competitions/categories/cat_notes.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 20 Sep 2018 04:17:50 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Metrics Optimization 2</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics-optimization-2/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org9a9e527" class="outline-2"&gt;
&lt;h2 id="org9a9e527"&gt;(R)MSPE, MAPE, and (R)MSLE&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9a9e527"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2b0a770" class="outline-3"&gt;
&lt;h3 id="org2b0a770"&gt;An Off-By-One Example&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2b0a770"&gt;
&lt;p&gt;
Suppose we are predicting sales for two shops and the two shops have different sales volumes but our predictions for both cases are off by one. In this case our Mean-Squared-Error (MSE) might be the same, but they have a different significance.
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;Shop&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Actual&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Predicted&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;MSE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;9&lt;/td&gt;
&lt;td class="org-left"&gt;10&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;999&lt;/td&gt;
&lt;td class="org-left"&gt;1,000&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7d129ef" class="outline-2"&gt;
&lt;h2 id="org7d129ef"&gt;Root Mean Squared Percentage Error and Mean Absolute Percentage Error&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7d129ef"&gt;
&lt;p&gt;
The MSE and Mean-Absolute-Error (MAE) are absolute errors which don't take into account how significant the error is. There are two relative errors,  Mean-Squared-Percentage-Error (MSPE) and Mean-Absolute-Percentage-Error (MAPE) that divide each error term by the actual value to give you a realive error instead of an absolute error.
&lt;/p&gt;

&lt;p&gt;
\[
MSPE = \frac{1}{N} \sum_{i=1}^n \left( \frac{y_i - \hat{y}}{y_i}\right)^2
\]
&lt;/p&gt;

&lt;p&gt;
\[
MAPE = \frac{1}{N} \sum_{i=1}^n \left| \frac{y_i - \hat{y}}{y_i}\right|
\]
&lt;/p&gt;

&lt;p&gt;
The MAPE will be inversely proportional to its target and the MSPE will be inversely proportional to the square of the target.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org33dedb3" class="outline-3"&gt;
&lt;h3 id="org33dedb3"&gt;Optimal Constant Predictions&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org33dedb3"&gt;
&lt;p&gt;
The best constant prediction you can make when using the Mean Squared Error is to predict the mean of the target values. The best prediction you can make for the MSPE is to take a weighted mean of the target values. The best constant prediction you can make for the Mean Absolute Percentage Error is the weighted median.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org72d9283" class="outline-2"&gt;
&lt;h2 id="org72d9283"&gt;Root Mean Squared Logarithmic Error (MSLE)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org72d9283"&gt;
&lt;p&gt;
\[
MSLE = \sqrt{\frac{1}{N}\sum_{i=1}^N (\log (y_i + 1) - \log(\hat{y}_i + 1))^2}\\
= \sqrt{MSE(\log(y_i + 1), \log(\hat{y}_i + 1))}
\]
&lt;/p&gt;

&lt;p&gt;
You add a 1 to each term to prevent you from trying to take the &lt;i&gt;log&lt;/i&gt; of 0, which is undefined. The RMSLE is biased toward predictions that are higher than the actual values rather than lower.
&lt;/p&gt;

&lt;p&gt;
These are the best constant predictions you can make for the competition data set.
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Metric&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Constant&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;MSE&lt;/td&gt;
&lt;td class="org-right"&gt;11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;RMSLE&lt;/td&gt;
&lt;td class="org-right"&gt;9.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;MAE&lt;/td&gt;
&lt;td class="org-right"&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;MSPE&lt;/td&gt;
&lt;td class="org-right"&gt;6.6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;MAPE&lt;/td&gt;
&lt;td class="org-right"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes metrics</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics-optimization-2/</guid><pubDate>Wed, 19 Sep 2018 15:04:33 GMT</pubDate></item><item><title>Metrics</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/#orgd5014ac"&gt;About Metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/#org4c7b753"&gt;The Most Common Metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd5014ac" class="outline-2"&gt;
&lt;h2 id="orgd5014ac"&gt;About Metrics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd5014ac"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2b7b99d" class="outline-3"&gt;
&lt;h3 id="org2b7b99d"&gt;What are metrics?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2b7b99d"&gt;
&lt;p&gt;
Metrics are numeric values that you are trying to optimize - they are how your model is graded.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8688e79" class="outline-3"&gt;
&lt;h3 id="org8688e79"&gt;Why are there so many metrics?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8688e79"&gt;
&lt;p&gt;
Each metric can tell you something different, so what metric you need depends on the problem you are trying to solve. For competitions, it is sometimes possible to do metrics probing just like you can sometimes do leaderboard probing to find peculiarities created by the chosen metric.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4c7b753" class="outline-2"&gt;
&lt;h2 id="org4c7b753"&gt;The Most Common Metrics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4c7b753"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdb984a1" class="outline-3"&gt;
&lt;h3 id="orgdb984a1"&gt;Regression&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdb984a1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc8c1fd7" class="outline-4"&gt;
&lt;h4 id="orgc8c1fd7"&gt;Mean Squared Error&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc8c1fd7"&gt;
&lt;p&gt;
This is the average of the square of the errors.
\[
MSE = \frac{1}{N}
\]
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdad37bb" class="outline-4"&gt;
&lt;h4 id="orgdad37bb"&gt;Root Mean Squared Error&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgdad37bb"&gt;
&lt;p&gt;
This is the square root of the mean squared error.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;minimizing the RMSE is also minimizes the MSE&lt;/li&gt;
&lt;li&gt;RMSE is more intuitive&lt;/li&gt;
&lt;li&gt;They can differ when used by gradient-based models&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2901caa" class="outline-4"&gt;
&lt;h4 id="org2901caa"&gt;R-squared&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2901caa"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Optimizing r-squared is equivalent to optimizing MSE&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3fed0d1" class="outline-4"&gt;
&lt;h4 id="org3fed0d1"&gt;Mean Absolute Error&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3fed0d1"&gt;
&lt;p&gt;
This is more common when you are explaining it to a non-statistician. It is also more robust. Mathematically, it isn't something that you can calculate the derivate for.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3e12f33" class="outline-4"&gt;
&lt;h4 id="org3e12f33"&gt;MAE vs MSE&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3e12f33"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Outliers: use MAE&lt;/li&gt;
&lt;li&gt;Unexpected Values that we should still care about (not true outliers (mistakes), just rare): use MSE&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8bb886e" class="outline-3"&gt;
&lt;h3 id="org8bb886e"&gt;Classification&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>metrics notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/metrics/</guid><pubDate>Tue, 18 Sep 2018 04:49:35 GMT</pubDate></item><item><title>Data Leaks</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/data-leaks/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-orgb6c4200" class="outline-2"&gt;
&lt;h2 id="orgb6c4200"&gt;What are data leaks?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb6c4200"&gt;
&lt;p&gt;
&lt;i&gt;Data Leaks&lt;/i&gt; are unexpected errors that expose extra information that wouldn't be available in production.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgafbb943" class="outline-2"&gt;
&lt;h2 id="orgafbb943"&gt;Time Series&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgafbb943"&gt;
&lt;p&gt;
Check if there are points in the training set that are in the future with regard to the test set.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org538834b" class="outline-2"&gt;
&lt;h2 id="org538834b"&gt;Unexpected Information&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org538834b"&gt;
&lt;p&gt;
Sometimes what looks like a non-predictive feature might prove to be useful because of the way the data-set was created.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;ID&lt;/li&gt;
&lt;li&gt;Row Order&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org165f78d" class="outline-2"&gt;
&lt;h2 id="org165f78d"&gt;Leaderboard Probing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org165f78d"&gt;
&lt;p&gt;
This is a method to look for dataleaks based on the leader board.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org33ada27" class="outline-2"&gt;
&lt;h2 id="org33ada27"&gt;Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org33ada27"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3c7ca32" class="outline-3"&gt;
&lt;h3 id="org3c7ca32"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3c7ca32"&gt;
&lt;p&gt;
Suppose that you have a credit scoring task where you have to create a machine learning model that approximates expert evaluation of an individual's creditworthiness. Which of the following can potentially be a data leakage?
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; An ID of a data point (row) in the train set corellates with the target variable (the data wasn't shuffled, this information won't work in a real-world scenario)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The first half of the data points in the train set have a score of 0 while the second half has scores &amp;gt; 0. (same as above)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Among he features you have a &lt;code&gt;company_id&lt;/code&gt;, an identifier of a company where this person works. It turns out that this feature is important and adding it to your model improves your score. (this is a normal feature, the fact that it improves your score just means it's an important feature)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2711f73" class="outline-3"&gt;
&lt;h3 id="org2711f73"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2711f73"&gt;
&lt;p&gt;
What is the most foolproof way to set up a time-series competition?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Split, train, public and private parts of the data by time. Remove all features except IDs from the test set so that participants will generate all the features based on the past and join them themselves. (you need to remove all features tfrom the test set to guarantee there isn't a data-leakage)&lt;/li&gt;

&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Make a time based split for train/test and a random split for publit/private. (this is vulnerable to leaderboard probing)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; split public and private by time, remove time from the test set. (it is possible to reverse engineer the time-ordering and exploit future-peeking)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org37344f4" class="outline-3"&gt;
&lt;h3 id="org37344f4"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org37344f4"&gt;
&lt;p&gt;
Suppose you have a binary feature classification task and it is evaluated by the logloss metric. You know that there are 10,000 entries in the public chunk of the test set and that a constant prediction of 0.3 gets a score of 1.01. The mean of the target variable in the training set is 0.44. What is the mean of the target variable in the public part  of the test data (up to 4 decimal places.)
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;0.44 (wrong)&lt;/li&gt;
&lt;li&gt;0.132 (wrong)&lt;/li&gt;
&lt;li&gt;1.33 (wrong)&lt;/li&gt;
&lt;li&gt;0.7712&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
\[
\frac{N_1}{N} = \frac{-L - \ln (1-C)}{\ln C - \ln (1 - C)}\\
= 0.7712\\
\]
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7e705bf" class="outline-3"&gt;
&lt;h3 id="org7e705bf"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7e705bf"&gt;
&lt;p&gt;
Suppose you are solving an image classification task, what is the classification of the logo for this course?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Angry robot (wrong - should be a number)&lt;/li&gt;
&lt;li&gt;1 (wrong - check image name)&lt;/li&gt;
&lt;li&gt;3 (the URL for the image had the answer in it)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>dataleaks notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/data-leaks/</guid><pubDate>Sat, 08 Sep 2018 23:11:07 GMT</pubDate></item><item><title>Validation</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/validation/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#orgdaf62d0"&gt;Validation and Overfitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org674da7d"&gt;Three Main Methods of Splitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#orgb5cdb96"&gt;Stratification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org388f244"&gt;Data Splitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org36f5ea8"&gt;Problems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org8238b42"&gt;Practice Quiz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org03ebc6f"&gt;Quiz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/validation/#org746ed2d"&gt;Links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdaf62d0" class="outline-2"&gt;
&lt;h2 id="orgdaf62d0"&gt;Validation and Overfitting&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdaf62d0"&gt;
&lt;p&gt;
To prevent your model from overfitting to the training set, you can hold out some of the training set and use it to validate the model after it has been fit to the rest of the training set.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Underfitting: your model isn't complex enough to capture the data&lt;/li&gt;
&lt;li&gt;Overfitting: your model is too complex and it is modelling noise in the data&lt;/li&gt;
&lt;li&gt;In a competition, if your model does well on the validation set but not on the test set, then it probably overfit the data you had&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org674da7d" class="outline-2"&gt;
&lt;h2 id="org674da7d"&gt;Three Main Methods of Splitting&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org674da7d"&gt;
&lt;p&gt;
These are methods for splitting your training set into training and validation sets. Once you have a model, re-train it over the entire training set before applying it to the test set.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdf752cb" class="outline-3"&gt;
&lt;h3 id="orgdf752cb"&gt;Holdout&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdf752cb"&gt;
&lt;p&gt;
This method just splits the data into one training and one validation set.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.ShuffleSplit.html"&gt;sklearn.model_selection.ShuffleSplit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngroups=1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge7e9228" class="outline-3"&gt;
&lt;h3 id="orge7e9228"&gt;K-Fold&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge7e9228"&gt;
&lt;p&gt;
Make &lt;i&gt;k&lt;/i&gt; splits of the training set, then use each of the validation sets while training on all the data not in the validation set. This differs from doing holdout k-times since we guarantee that the validation sets don't overlap. Uses the average score for the k-folds.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html"&gt;sklearn.model_selection.KFold&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0dbec8d" class="outline-3"&gt;
&lt;h3 id="org0dbec8d"&gt;Leave One Out&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0dbec8d"&gt;
&lt;p&gt;
This is like k-folds except we always use a validation set of size 1 - so we are iterating over each point in the data set and using it as the training set. This can be useful if the data set is small.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.LeaveOneOut.html"&gt;sklearn.model_selection.LeaveOneOut&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb5cdb96" class="outline-2"&gt;
&lt;h2 id="orgb5cdb96"&gt;Stratification&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb5cdb96"&gt;
&lt;p&gt;
Sometimes you need to make sure your validation sets have the same distribution as your set as a whole.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;small datasets&lt;/li&gt;
&lt;li&gt;unbalanced datasects&lt;/li&gt;
&lt;li&gt;multiclass classification&lt;/li&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedShuffleSplit.html"&gt;StratifieShuffleSplit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org388f244" class="outline-2"&gt;
&lt;h2 id="org388f244"&gt;Data Splitting&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org388f244"&gt;
&lt;p&gt;
If you have time-based data, there's two ways to split the training data - randomly within the entire timespan, or put the first part of the data in the training set and put the second part of the data in the validation set. If the test-set is a time that is beyond the training data, then using the time-based split will produce a model that is better for the testing data.
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Row-wise split
This is the most common case, where rows are randomly chosen from the training data. This assumes the rows are independent.&lt;/li&gt;
&lt;li&gt;Time-wise split
This is the case where you are predicting future values of a time-series. In this case, the further back in time a row is, the less like the future value it is.&lt;/li&gt;
&lt;li&gt;By-ID
In this case several rows map to one ID, and the ID maps to a target. For example, you might have several x-rays for one patient that map to one diagnosis.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
The main point of this is that you want to set up your validation set to match the way the train-test sets were split.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org36f5ea8" class="outline-2"&gt;
&lt;h2 id="org36f5ea8"&gt;Problems&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org36f5ea8"&gt;
&lt;p&gt;
The point of doing the training-validation split is that you think the validation set(s) will approximate the test set. But what if that's not true?
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6727bfa" class="outline-3"&gt;
&lt;h3 id="org6727bfa"&gt;Causes of score differences&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6727bfa"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Too little data&lt;/li&gt;
&lt;li&gt;The data is too diverse and inconsistent&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf901a8f" class="outline-3"&gt;
&lt;h3 id="orgf901a8f"&gt;Submission Differs from Validation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf901a8f"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Even K-fold validation has variation (check that the standard deviation across folds encompasses the leaderboard values)&lt;/li&gt;
&lt;li&gt;Too little data on leaderboard (nothing you can do)&lt;/li&gt;
&lt;li&gt;Train and test are from different distributions&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8238b42" class="outline-2"&gt;
&lt;h2 id="org8238b42"&gt;Practice Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8238b42"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org352f592" class="outline-3"&gt;
&lt;h3 id="org352f592"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org352f592"&gt;
&lt;p&gt;
We did a K-Fold cross validation on a huge dataset and noticed that scores on each fold are roughly the same. Which validation type is of most practical use?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; K-Fold&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Holdout&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Leave one out&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0326285" class="outline-3"&gt;
&lt;h3 id="org0326285"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0326285"&gt;
&lt;p&gt;
We did a K-fold cross validation on a medium sized dataset and noticed that the validation scores varied widely. Which validation type is the most practical to use?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Leave One Out&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; K Fold&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Houldout&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc71db56" class="outline-3"&gt;
&lt;h3 id="orgc71db56"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc71db56"&gt;
&lt;p&gt;
The features we generate depend on the train-test split. True or False?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; True&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; False&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd543efe" class="outline-3"&gt;
&lt;h3 id="orgd543efe"&gt;Which of these can indicate an expected leaderboard shuffle in a competition?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd543efe"&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Little training and/or testing data&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Most of the competitors have similar scores&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Different public/private data or target distributions&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org03ebc6f" class="outline-2"&gt;
&lt;h2 id="org03ebc6f"&gt;Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org03ebc6f"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org10427ff" class="outline-3"&gt;
&lt;h3 id="org10427ff"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org10427ff"&gt;
&lt;p&gt;
Select the true statements.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; A performance increase on a fixed cross-validation split guarantees a performance increase on any cross-validation split. (You might be overfitting. You should change the splits to check for overfitting.)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The logic behind the validation split should mimic the logic behind the train-test split (this is the main rule for making a reliable validation)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Underfitting refers to not capturing enough patterns in the data&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; We use validation to estimate the quality of our model (this is the main purpose of validation)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; The model that does on the validation set is guaranteed to do the best on the test set. (The test and validation sets might have different distributions, in which case the validation won't predict the test set score)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf19d4e6" class="outline-3"&gt;
&lt;h3 id="orgf19d4e6"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf19d4e6"&gt;
&lt;p&gt;
Kaggle usually allows you to submit two final submissions that will be checked against the private leader board. One common practice is to use a model that did the best on the validation scores and another that did best on the public leader board. What is the logic behind using these two models?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; People rarely overfit the public leaderboard. You almost always have a lot of test data and it is hard to overfit.&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Validation is rarely valid in competitions. You must account for the case where validation worked and where it didn't.&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The test set may have a different distribution than the target data. If this is true, then the model that did better on the public leaderboard will do better. If not, then the model that did better in validation will do better.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8c9f4e2" class="outline-3"&gt;
&lt;h3 id="org8c9f4e2"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8c9f4e2"&gt;
&lt;p&gt;
Suppose we have a dataset of marketing campaigns. Each campain runs for a few weeks and for each campaign our target is the number of new customers. A row in the dataset looks like this:
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Campaign ID, Date, {some features},Number of New Customers&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
The dataset contains multiple campaigns where the training set has the dates at the start of each campaign and the test set has the dates at the end of each campaign. Which train/test split should you use?
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Random Split&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Combined Split (Each train and test set are divided by a date and the date might be for different campaigns, so it is a combination of campaign ID and date)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; ID-based split (wrong)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Time-based split (wrong)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1d64e74" class="outline-3"&gt;
&lt;h3 id="org1d64e74"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1d64e74"&gt;
&lt;p&gt;
Which of the following can you usually identify without the leaderboard?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Different scores/optimal parameters between different folds (this is determined during validation)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Train and test target data are from different distributions (You would need the test target values to figure this out, which you won't have)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The public leaderboard score will be unreliable because there is too little data (you can check this by making the size of the folds match the size of the public test set and see the variability)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The train and test data are from different distributions (you can often figure this out during Exploratory Data Analysis)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org746ed2d" class="outline-2"&gt;
&lt;h2 id="org746ed2d"&gt;Links&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org746ed2d"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/cross_validation.html"&gt;Cross-validation in sklearn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chioka.in/how-to-select-your-final-models-in-a-kaggle-competitio/"&gt;Model Selection for Kaggle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes validation</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/validation/</guid><pubDate>Tue, 04 Sep 2018 15:01:59 GMT</pubDate></item><item><title>Springleaf Competition</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/springleaf-competition/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-orgd3acf9c" class="outline-2"&gt;
&lt;h2 id="orgd3acf9c"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd3acf9c"&gt;
&lt;p&gt;
The data comes from the &lt;a href="https://www.kaggle.com/c/springleaf-marketing-response"&gt;Springleaf Marketing Response&lt;/a&gt; competition. Springleaf makes personal loans and wanted to be able to predict who would respond to their direct mail offers. Submissions are evaluated on the area under the ROC curve between the predicted probability and the target. The submission file should have an ID and the probability that the person would respond.
&lt;/p&gt;

&lt;pre class="example"&gt;
ID,target
1,0.35
3,0.01
6,0.93333
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>example competition notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/springleaf-competition/</guid><pubDate>Tue, 04 Sep 2018 13:35:25 GMT</pubDate></item><item><title>Exploratory Data Analysis</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/#orga7ca7b0"&gt;Building Your Intuition About the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/#org6ae1a4e"&gt;Exploring Anonymized Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/#orga42a7b7"&gt;Visualizations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/#org70345c8"&gt;Data Set Cleaning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/#orgf6f6742"&gt;Quiz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/#orgeedcf2a"&gt;Links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga7ca7b0" class="outline-2"&gt;
&lt;h2 id="orga7ca7b0"&gt;Building Your Intuition About the Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga7ca7b0"&gt;
&lt;p&gt;
The first thing to do is to see if you can build up a mental model of what the data is about.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0a1a14d" class="outline-3"&gt;
&lt;h3 id="org0a1a14d"&gt;Get Domain Knowledge&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0a1a14d"&gt;
&lt;p&gt;
Find out something about the topic that the data describes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge4755c2" class="outline-3"&gt;
&lt;h3 id="orge4755c2"&gt;Check if the Data is intuitive&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge4755c2"&gt;
&lt;p&gt;
See if there are any strange values and see if it makes sense given the data description.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4a6688e" class="outline-3"&gt;
&lt;h3 id="org4a6688e"&gt;Understand how the data was generated&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4a6688e"&gt;
&lt;p&gt;
Is any of it synthetic? Was the training data generated the same way as the testing data?
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6ae1a4e" class="outline-2"&gt;
&lt;h2 id="org6ae1a4e"&gt;Exploring Anonymized Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6ae1a4e"&gt;
&lt;p&gt;
Organizers sometimes encode data so you can't tell what it is.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6c5093d" class="outline-3"&gt;
&lt;h3 id="org6c5093d"&gt;Try To Decode the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6c5093d"&gt;
&lt;p&gt;
You generally won't be able to figure out what the data is if it's encoded, but sometimes they were created using simple shifting schemes that will let you figure out their original values.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3a18170" class="outline-3"&gt;
&lt;h3 id="org3a18170"&gt;Explore Individual Features&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3a18170"&gt;
&lt;p&gt;
Even if you don't know what the data is, it's important to know what type of data it is so that you can use the right data preprocessing for your model.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.dtypes.html"&gt;df.dtypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.info.html"&gt;df.info()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.value_counts.html"&gt;x.value_counts()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.isnull.html"&gt;x.isnull()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga42a7b7" class="outline-2"&gt;
&lt;h2 id="orga42a7b7"&gt;Visualizations&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga42a7b7"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0a8d1b7" class="outline-3"&gt;
&lt;h3 id="org0a8d1b7"&gt;Features&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0a8d1b7"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0324b8b" class="outline-4"&gt;
&lt;h4 id="org0324b8b"&gt;Histograms&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0324b8b"&gt;
&lt;p&gt;
This is useful for seeing the shape of the data.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;pyplot.hist(x)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge6ca6ac" class="outline-4"&gt;
&lt;h4 id="orge6ca6ac"&gt;Index vs Value&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge6ca6ac"&gt;
&lt;p&gt;
This will show you how well distributed the data is within the data frame. Horizontal lines indicate repeated values and empty bands show areas where none of the data had this value. If you don't have vertical lines then the data was probably shuffled.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;pyplot.plot(x, '.')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9059dc9" class="outline-4"&gt;
&lt;h4 id="org9059dc9"&gt;Index vs Value Colored By Class Label&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org9059dc9"&gt;
&lt;p&gt;
If you plot the classes with different colors you can see if there are clusters and clear separations between them. (&lt;code&gt;y&lt;/code&gt; in the function call has the target values).
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;pyplot.scatter(range(len(x)), x, c=y)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf7a10aa" class="outline-4"&gt;
&lt;h4 id="orgf7a10aa"&gt;Plot Other Things&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf7a10aa"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Row vs Feature&lt;/li&gt;
&lt;li&gt;Nan-values&lt;/li&gt;
&lt;li&gt;Value Counts&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org90bcaff" class="outline-3"&gt;
&lt;h3 id="org90bcaff"&gt;Relationships&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org90bcaff"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5fbfc32" class="outline-4"&gt;
&lt;h4 id="org5fbfc32"&gt;Scatter Plots&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org5fbfc32"&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org2ba358a"&gt;&lt;/a&gt;Pairwise Relationships&lt;br&gt;
&lt;div class="outline-text-5" id="text-org2ba358a"&gt;
&lt;p&gt;
To make it eaiser to see relationships, you can plot them in pairs.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;pyplot.scatter(x1, x2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org0c1ba14"&gt;&lt;/a&gt;Compare the Test Set&lt;br&gt;
&lt;div class="outline-text-5" id="text-org0c1ba14"&gt;
&lt;p&gt;
Plot the features and the test-set (using different colors) to see how well your training data matches your test data.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="orgd7983ec"&gt;&lt;/a&gt;Scatter Matrix&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgd7983ec"&gt;
&lt;p&gt;
Pandas has a convenience function that will plot all the pairwise scatter-plots for you.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;pandas.scatter_matrix(X)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge4c5609" class="outline-4"&gt;
&lt;h4 id="orge4c5609"&gt;Corellation&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge4c5609"&gt;
&lt;p&gt;
Plot the corellation matrix to see if there are feature-pairs that are related so you can make a new feature out of them and see if they help.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;X.corr(), pyplot.matshow()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
A straight correllation matrix might give you a sense of how correllated the features are, but it's more useful to use a clustering algorithm to see if there are groups within the correlation matrix.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0f78f2b" class="outline-4"&gt;
&lt;h4 id="org0f78f2b"&gt;Plot Statistics&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0f78f2b"&gt;
&lt;p&gt;
Try plotting mean, differences, combination counts, etc. and see if you can create groups out of them.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org70345c8" class="outline-2"&gt;
&lt;h2 id="org70345c8"&gt;Data Set Cleaning&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org70345c8"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgae0f01b" class="outline-3"&gt;
&lt;h3 id="orgae0f01b"&gt;Duplicated and Constant Features&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgae0f01b"&gt;
&lt;p&gt;
Sometimes a feature will have the same value in all the rows. If it's this way in both the training and test sets you can just remove it, but if there are different values in the test set you have to figure out how to handle them.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;x_train.nunique(axis&lt;/code&gt;"columns") &lt;code&gt;= 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Sometimes columns will get duplicated in which case you should drop one of them.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;x_train.T.drop_duplicates()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This can happen with rows as well, but it can be harder to decide whether this is a mistake or not.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org601f9d8" class="outline-3"&gt;
&lt;h3 id="org601f9d8"&gt;Non-shuffled Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org601f9d8"&gt;
&lt;p&gt;
If you plot the mean as a horizontal line the data should be evenly distributed around it, if not it might not have been shuffled and there could be an inadvertent pattern in the data. You might not be able to use it, but you should understand all the things about the data that you can find out.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf6f6742" class="outline-2"&gt;
&lt;h2 id="orgf6f6742"&gt;Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf6f6742"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgfb0f911" class="outline-3"&gt;
&lt;h3 id="orgfb0f911"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfb0f911"&gt;
&lt;p&gt;
Suppose we are given a data set with features &lt;i&gt;X&lt;/i&gt;, &lt;i&gt;Y&lt;/i&gt;, and &lt;i&gt;Z&lt;/i&gt;. Can you recover &lt;i&gt;z&lt;/i&gt; as a function of &lt;i&gt;x&lt;/i&gt; and &lt;i&gt;y&lt;/i&gt;?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Z = X/Y&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Z = X - Y&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Z = X + Y&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Z = XY&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2f5a3ba" class="outline-3"&gt;
&lt;h3 id="org2f5a3ba"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2f5a3ba"&gt;
&lt;p&gt;
What value do the red dots have?
0.5 (wrong)
2 (next try)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3c2f040" class="outline-3"&gt;
&lt;h3 id="org3c2f040"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3c2f040"&gt;
&lt;p&gt;
What hypothesis about X can we not reject based on the plots?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; X is a counter or label encoded categorical feature&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; X can be the temperature (in Celsius) in different cities at different times. (the values are probably out of range)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; X can take a value of zero (The log plot would have values at 0 but it doesn't)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; X takes only discrete values (the horizontal lines indicate that there are repeated values with discrete values)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; 2 &amp;lt;= X &amp;lt; 3 happens more frequently than 3 &amp;lt;= X &amp;lt; 4&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4560230" class="outline-3"&gt;
&lt;h3 id="org4560230"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4560230"&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Target is completely determined by coordinates (x,y)(x,y)(x,y), i.e. the label of the point is completely determined by point's position (x,y)(x,y)(x,y). Saying the same in other words: if we only had two features (x,y)(x,y)(x,y), we could build a classifier, that is accurate 100% of time.&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; The top right plot is better than the top left in that everything you get from the top left can also be gotten from the top right, but not the other way around.&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; standard deviation for jittering is the largest on the bottom right.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgeedcf2a" class="outline-2"&gt;
&lt;h2 id="orgeedcf2a"&gt;Links&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgeedcf2a"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/auto_examples/bicluster/plot_spectral_biclustering.html"&gt;Sorting Correlation Plots&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>notes data</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/exploratory-data-analysis/</guid><pubDate>Tue, 04 Sep 2018 04:24:53 GMT</pubDate></item><item><title>Feature Extraction From Text and Images</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/feature-extraction-from-text-and-images/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-extraction-from-text-and-images/#org9c16155"&gt;How do you convert text to data?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-extraction-from-text-and-images/#org5dffe75"&gt;Practice Quiz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-extraction-from-text-and-images/#org4442b30"&gt;Quiz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-extraction-from-text-and-images/#org91a564a"&gt;Links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9c16155" class="outline-2"&gt;
&lt;h2 id="org9c16155"&gt;How do you convert text to data?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9c16155"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1e94a7a" class="outline-3"&gt;
&lt;h3 id="org1e94a7a"&gt;Two Main Methods&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1e94a7a"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgda76e36" class="outline-4"&gt;
&lt;h4 id="orgda76e36"&gt;Bag Of Words&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgda76e36"&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org9a9fdf5"&gt;&lt;/a&gt;Vectorization&lt;br&gt;
&lt;div class="outline-text-5" id="text-org9a9fdf5"&gt;
&lt;p&gt;
This method counts the number of occurrences of each word in the source. For each word it creates a column and then in the row puts the counts for that instance of data.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Sklearn implements this with &lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html"&gt;CountVectorizer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org7321050"&gt;&lt;/a&gt;Term Frequency/Inverse Document Frequency (TF/IDF)&lt;br&gt;
&lt;div class="outline-text-5" id="text-org7321050"&gt;
&lt;p&gt;
This method tries to make word counts comparable even if the texts are of different sizes and also to emphasize more important words.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Term Frequency: Normalize rows so all values are from 0 to 1 to make texts of different sizes comparable&lt;/li&gt;
&lt;li&gt;Inverse Document Frequency: Normalize columns to make emphasize more important features&lt;/li&gt;
&lt;li&gt;Sklearn implements this with &lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html"&gt;TfidVectorizer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="orga6e7cf6"&gt;&lt;/a&gt;N-Grams&lt;br&gt;
&lt;div class="outline-text-5" id="text-orga6e7cf6"&gt;
&lt;p&gt;
This method that creates a bag of words by grouping them into sub-sequences of words. A 3-gram, for instance, sweeps the text to create sequences of words made up of 3 adjacent words.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://sklearn.feature_extraction.text.countvectorizer"&gt;Count Vectorizer&lt;/a&gt; is sklearn's implementation&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org8964ede"&gt;&lt;/a&gt;Text Preprocessing&lt;br&gt;
&lt;div class="outline-text-5" id="text-org8964ede"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;lowercase:
Change all the words to lower-case&lt;/li&gt;
&lt;li&gt;lemmatization:
Try to reduce word to a common case (e.g. democratization, democracy, democratic all become democracy)&lt;/li&gt;
&lt;li&gt;stemming:
Try to reduce word to a root (e.g. democratization, democracy, democratic all become democ)&lt;/li&gt;
&lt;li&gt;stopwords:
Remove common words (e.g. a, and, or, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="orgf4056ec"&gt;&lt;/a&gt;The Bag Of Words Pipeline&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgf4056ec"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Preprocessing (lowercase, lemmatization, stemming, stopwords)&lt;/li&gt;
&lt;li&gt;Create n-grams&lt;/li&gt;
&lt;li&gt;Postprocessing: TF/IDF&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-org31719ec" class="outline-4"&gt;
&lt;h4 id="org31719ec"&gt;Embeddings (e.g. Word2Vec)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org31719ec"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Uses neural-nets&lt;/li&gt;
&lt;li&gt;much smaller vectors than bag of words&lt;/li&gt;
&lt;li&gt;But each word gets a vector so many more vectors&lt;/li&gt;
&lt;li&gt;similar words have similar word-vectors&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5dffe75" class="outline-2"&gt;
&lt;h2 id="org5dffe75"&gt;Practice Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5dffe75"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1df0b48" class="outline-3"&gt;
&lt;h3 id="org1df0b48"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1df0b48"&gt;
&lt;p&gt;
TF-IDF is applied to a matrix where each column represents a word, each row represents a document, and each value shows the number of times a particular word occurred in a particular document. Choose the correct statements.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; IDF scales features inversely proprotionally to a number of word occurrences over documents&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; IDF scales features proportionally to the frequency of the a word's occurrences&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; TF normalizes sums of the row values to 1&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; TF normalizes sums of the column values to 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org08ecc1c" class="outline-3"&gt;
&lt;h3 id="org08ecc1c"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org08ecc1c"&gt;
&lt;p&gt;
Which of these methods can be used to preprocess text?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; stemming&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Lower-case transformation&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Lemmatization&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Stopword removal&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Levenshteining&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; plumping&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; plumbing&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3c0d557" class="outline-3"&gt;
&lt;h3 id="org3c0d557"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3c0d557"&gt;
&lt;p&gt;
What is the main purpose of lemmatization and stemming?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; to remove words which are not useful&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; to remove inflectional forms and sometimes derivationally related forms of a word to a common base form&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; To reduce the significance of common words&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; to induce common word amplification standards to the most useful for machine learning algorithms form&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbfb5d8c" class="outline-3"&gt;
&lt;h3 id="orgbfb5d8c"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgbfb5d8c"&gt;
&lt;p&gt;
To learn Word2Vec embeddings we need:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; GloVe embeddings&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Labels for the documents in the corpora&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Labels for each word in the documents in the corpora&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Text corpora&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4442b30" class="outline-2"&gt;
&lt;h2 id="org4442b30"&gt;Quiz&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4442b30"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4aec9c8" class="outline-3"&gt;
&lt;h3 id="org4aec9c8"&gt;One&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4aec9c8"&gt;
&lt;p&gt;
Select true statements about n-grams.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Levenshteining should always be applied before computing n-grams (there is no such thing as Levenshteining)&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; n-grams always help increase significance of important words (n-grams are about counts, not importance)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; n-grams features are typically sparse (n-grams count occurrences of words and not every word will be found in every document)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; n-grams can help utilize local context around each word (n-grams encode sequences of words)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org54643b5" class="outline-3"&gt;
&lt;h3 id="org54643b5"&gt;Two&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org54643b5"&gt;
&lt;p&gt;
Select the true statements.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Bag of words usually produces longer vectors than Word2Vec (The number of features with BOW is equal to the number of unique words, Word2Vec limit is set beforehand)&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; Semantically similar words usually have similar word2vec embeddings&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; You do not need bag of words features in a competition if you have word2vec features (both approaches are useful and can work together)
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; The meaning of each value in the Bag of Words matrix is unknown (The meaning of each value is how many times it occurred)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org81e0f32" class="outline-3"&gt;
&lt;h3 id="org81e0f32"&gt;Three&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org81e0f32"&gt;
&lt;p&gt;
Suppose in a new competition we are given a dataset of 2D medical images. We want to extract image descriptors from a hidden layer of a neural network pretrained on the ImageNet dataset. We will then use extracted descriptors to train a simple logistic regression model to classify images from our dataset.
&lt;/p&gt;

&lt;p&gt;
We are considering using two networks: ResNet-50 with an ImageNet accuracy of X and VGG-16 with an ImageNet accuracy of Y (X &amp;lt; Y). Select the true statements.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; With one pretrained CNN model you can get only one vector of descriptors for an image&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Descriptors from ResNet 50 will always be better than the ones from VG-16 in our pipeline&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; It is not clear what descriptors are better on our dataset. We should evaluate both.
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; Descriptors from ResNet-50 and VGG-16 are always very similar in cosine distance&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; For any image, descriptors from the last hidden layer of ResNet-50 are the same as the descriptors from the last hidden layer of VGG-16&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb5fd47f" class="outline-3"&gt;
&lt;h3 id="orgb5fd47f"&gt;Four&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb5fd47f"&gt;
&lt;p&gt;
Data augmentation can be used at (1) train time and (2) test time
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; True, False&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; False, True&lt;/li&gt;
&lt;li class="on"&gt;&lt;code&gt;[X]&lt;/code&gt; True, True&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[ ]&lt;/code&gt; False, False&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org91a564a" class="outline-2"&gt;
&lt;h2 id="org91a564a"&gt;Links&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org91a564a"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2dea633" class="outline-3"&gt;
&lt;h3 id="org2dea633"&gt;Text&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2dea633"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org888604f" class="outline-4"&gt;
&lt;h4 id="org888604f"&gt;Bag Of Words&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org888604f"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/feature_extraction.html"&gt;SKlearn on feature extraction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://andhint.github.io/machine-learning/nlp/Feature-Extraction-From-Text/"&gt;blog post&lt;/a&gt; on extracting features from text&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org47d387e" class="outline-4"&gt;
&lt;h4 id="org47d387e"&gt;Word2Vec&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org47d387e"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.tensorflow.org/tutorials/representation/word2vec"&gt;TensorFlow tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rare-technologies.com/word2vec-tutorial/"&gt;Blog post tutorial&lt;/a&gt; by the author of gensim&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nadbordrozd.github.io/blog/2016/05/20/text-classification-with-word2vec/"&gt;Text Classification post&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://taylorwhitten.github.io/blog/word2vec"&gt;Another introduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga0fdad3" class="outline-4"&gt;
&lt;h4 id="orga0fdad3"&gt;Natural Language Processing with Python&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orga0fdad3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://www.nltk.org/"&gt;nltk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://textblob.readthedocs.io/en/dev/"&gt;TextBlob&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgab0ffa7" class="outline-3"&gt;
&lt;h3 id="orgab0ffa7"&gt;Images&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgab0ffa7"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd0cb270" class="outline-4"&gt;
&lt;h4 id="orgd0cb270"&gt;Pre-trained Models&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgd0cb270"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://keras.io/applications/"&gt;Keras&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kernix.com/blog/image-classification-with-a-pre-trained-deep-neural-network_p11"&gt;How To use a pre-trained model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7540737" class="outline-4"&gt;
&lt;h4 id="org7540737"&gt;Fine-Tuning&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7540737"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.tensorflow.org/hub/tutorials/image_retraining"&gt;Re-train a tensorflow image classifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://flyyufelix.github.io/2016/10/08/fine-tuning-in-keras-part2.html"&gt;Fine-tuning deep learning models in keras&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>featureextraction text images notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/feature-extraction-from-text-and-images/</guid><pubDate>Mon, 13 Aug 2018 14:17:52 GMT</pubDate></item><item><title>Feature Preprocessing</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/#org8e3a332"&gt;Preprocessing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/#orgc6c31cb"&gt;Numeric Feature Preprocessing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/#org31a0d5a"&gt;Categorical And Ordinal Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/#orgd4f08b1"&gt;Dates and Times&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/#org07a3cc1"&gt;Coordinates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/#org83e3295"&gt;Missing Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/#orgd8aeba7"&gt;Links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8e3a332" class="outline-2"&gt;
&lt;h2 id="org8e3a332"&gt;Preprocessing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8e3a332"&gt;
&lt;p&gt;
In every competition you need to:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;pre-process the data&lt;/li&gt;
&lt;li&gt;generate new features from the existing ones&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc6c31cb" class="outline-2"&gt;
&lt;h2 id="orgc6c31cb"&gt;Numeric Feature Preprocessing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc6c31cb"&gt;
&lt;p&gt;
Some models (e.g. Linear Classification) need you to convert numeric-looking data to categorical data. Tree-based models don't need pre-processing as much as non tree-based models do.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1b071b2" class="outline-3"&gt;
&lt;h3 id="org1b071b2"&gt;Scaling&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1b071b2"&gt;
&lt;p&gt;
If features have different value ranges then the model will  treat them differently.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html"&gt;sklearn.preprocessing.MinMaxScalar&lt;/a&gt;
Scale by the range of values&lt;/li&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html"&gt;sklearn.preprocessing.StandardScalar&lt;/a&gt;
Scale the data to have a mean of 0 and a standard deviation of 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1edcf2d" class="outline-3"&gt;
&lt;h3 id="org1edcf2d"&gt;Outliers&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1edcf2d"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Clip (&lt;a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html"&gt;numpy.clip&lt;/a&gt;)values to get rid of unusual values that mess with the model. (Winsorization)&lt;/li&gt;
&lt;li&gt;Rank Transform them (&lt;a href="https://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.stats.rankdata.html"&gt;scipy.stats.rankdata&lt;/a&gt;) so that they are ordered and have the same distance between them (they are uniformly distributed)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9fded10" class="outline-3"&gt;
&lt;h3 id="org9fded10"&gt;Transformation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9fded10"&gt;
&lt;p&gt;
For linear models and neural networks, transforming the data can sometimes help.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Log Transform: &lt;a href="https://duckduckgo.com/?q=numpy+log&amp;amp;t=canonical&amp;amp;ia=web"&gt;numpy.log(1 + x)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Power Less Than 1 Transform: &lt;a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html"&gt;numpy.sqrt(x + 2/3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga5948c5" class="outline-3"&gt;
&lt;h3 id="orga5948c5"&gt;Feature Generation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga5948c5"&gt;
&lt;p&gt;
Sometimes you can convert separate columns to get new ones. This requires exploratory data analysis.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Fractional Parts: people perceive numbers with fractions differently so sometime separating out the fractional part makes the model perform better because it is the more important part&lt;/li&gt;
&lt;li&gt;You can derive new values mathematically (e.g. distance using height and width)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org31a0d5a" class="outline-2"&gt;
&lt;h2 id="org31a0d5a"&gt;Categorical And Ordinal Features&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org31a0d5a"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Ordinal Features have an ordering but even if they are labeled numerically (e.g. 1, 2, 3) they aren't numeric because there is no implication about the distance between them&lt;/li&gt;
&lt;li&gt;label and frequency encoding are commonly used for tree-based models&lt;/li&gt;
&lt;li&gt;one-hot encoding is more common for non-tree-based models&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-org24d12b7" class="outline-3"&gt;
&lt;h3 id="org24d12b7"&gt;Label Encoding&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org24d12b7"&gt;
&lt;p&gt;
Some models need numeric values or numeric values that don't have implied ordering so you want to encode them.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html"&gt;sklearn.preprocessing.LabelEncoder&lt;/a&gt;
Sorts the labels then encodes them as integers&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.factorize.html"&gt;Pandas.factorize&lt;/a&gt;
Encodes the labels in the order they appear. This makes more sense if there is a meaning to the order in which labels appear.&lt;/li&gt;
&lt;li&gt;This is more commonly used with tree-based methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org893c37a" class="outline-3"&gt;
&lt;h3 id="org893c37a"&gt;Frequency Encoding&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org893c37a"&gt;
&lt;p&gt;
Encode the values to a fraction of all the labels. Can work with linear models if the frequency is correlated with the target value.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;titanic.groupby("Embarked").size()/len(titanic)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;from scipy.stats import rankedata&lt;/code&gt; (&lt;a href="https://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.stats.rankdata.html"&gt;rankedata&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;More common with tree-based methods&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org52efe19" class="outline-3"&gt;
&lt;h3 id="org52efe19"&gt;One Hot Encoding&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org52efe19"&gt;
&lt;p&gt;
Creates one column for each label and puts a 1 in the column that matches. Works with both linear and tree-based models, but can be inefficient with tree-based models.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html"&gt;pandas.get_dummies&lt;/a&gt; - converts strings into column encodings&lt;/li&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html"&gt;sklearn.preprocessing.OneHotEncoder&lt;/a&gt; - converts numeric categorical data into column encodings&lt;/li&gt;
&lt;li&gt;One hot encoding is better for non-tree models.&lt;/li&gt;
&lt;li&gt;This allows easier feature interactions (encode combined features (e.g. gender and class) rather than encoding them separately) 
&lt;ul class="org-ul"&gt;
&lt;li&gt;This is more common with linear models and KNN&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd4f08b1" class="outline-2"&gt;
&lt;h2 id="orgd4f08b1"&gt;Dates and Times&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd4f08b1"&gt;
&lt;p&gt;
When working with seasonal data, sometimes the relative date-stamps are more important than the actual dates (how close to Christmas?).
Sometimes you want the time between events.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org07a3cc1" class="outline-2"&gt;
&lt;h2 id="org07a3cc1"&gt;Coordinates&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org07a3cc1"&gt;
&lt;p&gt;
Sometimes you want exact coordinates, but most times you want distances to some center.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org83e3295" class="outline-2"&gt;
&lt;h2 id="org83e3295"&gt;Missing Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org83e3295"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;"missing" data might mean outliers - values that are probably wrong&lt;/li&gt;
&lt;li&gt;avoid replacing missing values before feature engineering - it can throw off what you do&lt;/li&gt;
&lt;li&gt;Gradient Boost Trees can handle isNaN, so you don't have to do anything&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf70f97d" class="outline-3"&gt;
&lt;h3 id="orgf70f97d"&gt;Numeric&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf70f97d"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4336bdd" class="outline-4"&gt;
&lt;h4 id="org4336bdd"&gt;Fill NA Approaches&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org4336bdd"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;-999, -1, other numbers
&lt;ul class="org-ul"&gt;
&lt;li&gt;lets you categorize missing values&lt;/li&gt;
&lt;li&gt;throws some models off (e.g. linear models and neural networks)&lt;/li&gt;
&lt;li&gt;one solution is to create a new feature for missing values, but this has now increased the amount of data you need (curse of dimensionality)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;mean, median, some central tendency
&lt;ul class="org-ul"&gt;
&lt;li&gt;This can throw the model off&lt;/li&gt;
&lt;li&gt;it is sometimes better to ignore missing data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;recronstructed value&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd8aeba7" class="outline-2"&gt;
&lt;h2 id="orgd8aeba7"&gt;Links&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd8aeba7"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbf88210" class="outline-3"&gt;
&lt;h3 id="orgbf88210"&gt;Feature Pre-processing&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgbf88210"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://scikit-learn.org/stable/modules/preprocessing.html"&gt;SKlearn's Preprocessing Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.coursera.org/learn/machine-learning/lecture/xx3Da/gradient-descent-in-practice-i-feature-scaling"&gt;Andrew Ng on Feature Scaling and its effect on Gradient Descent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://sebastianraschka.com/Articles/2014_about_feature_scaling.html"&gt;Sebastian Raschka on Feature Scaling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgff37823" class="outline-3"&gt;
&lt;h3 id="orgff37823"&gt;Feature Engineering&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgff37823"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/"&gt;Machine Learning Mastery on Feature Engineering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.quora.com/What-are-some-best-practices-in-Feature-Engineering"&gt;Quora: What are some best practices in Feature Engineering?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>features preprocessing notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/feature-preprocessing/</guid><pubDate>Wed, 08 Aug 2018 04:41:10 GMT</pubDate></item><item><title>Machine Learning Recap</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/machine-learning-recap/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org3fe09a4" class="outline-2"&gt;
&lt;h2 id="org3fe09a4"&gt;The Main Categories&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3fe09a4"&gt;
&lt;p&gt;
These are the four main categories of supervised machine learning algorithms that you'll encounter in kaggle competitions.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Linear Models
&lt;ul class="org-ul"&gt;
&lt;li&gt;sklearn&lt;/li&gt;
&lt;li&gt;vowpal rabbit (for really large datasets)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tree-Based Models
&lt;ul class="org-ul"&gt;
&lt;li&gt;sklearn&lt;/li&gt;
&lt;li&gt;xgboost: faster than sklearn&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;k-Nearest Neighbors
&lt;ul class="org-ul"&gt;
&lt;li&gt;sklearn&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Neural Networks&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org48f724a" class="outline-2"&gt;
&lt;h2 id="org48f724a"&gt;The No Free Lunch Theorem&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org48f724a"&gt;
&lt;blockquote&gt;
&lt;p&gt;
There is no method which outperforms all others for all tasks.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
You cannot assume that an algorithm that did well on one set of data will do well on another. All algorithms have weaknesses, so you have to test multiple algorithms on each data set.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org60a669b" class="outline-2"&gt;
&lt;h2 id="org60a669b"&gt;Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org60a669b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;there is no one algorithm to rule them all&lt;/li&gt;
&lt;li&gt;Linear models split spaces into two sub-spaces&lt;/li&gt;
&lt;li&gt;tree-based models spit spaces into boxes&lt;/li&gt;
&lt;li&gt;kNN relies on measuring the 'closeness' between points&lt;/li&gt;
&lt;li&gt;Neural Networks provide non-linear decision boundaries&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In general the two most powerful methods are &lt;b&gt;Gradient Boosted Decision Trees&lt;/b&gt; and &lt;b&gt;Neural Networks&lt;/b&gt;, but this won't always be the case.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>basics algorithms notes</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/machine-learning-recap/</guid><pubDate>Sun, 05 Aug 2018 01:13:44 GMT</pubDate></item><item><title>Real-World vs Kaggle</title><link>https://necromuralist.github.io/Kaggle-Competitions/posts/real-world-vs-kaggle/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org22d9484" class="outline-2"&gt;
&lt;h2 id="org22d9484"&gt;A Real World Pipeline&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org22d9484"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;What is the business problem that you are trying to solve?&lt;/li&gt;
&lt;li&gt;What is the formal version of the problem?&lt;/li&gt;
&lt;li&gt;How do you collect data?&lt;/li&gt;
&lt;li&gt;How do you preprocess the data?&lt;/li&gt;
&lt;li&gt;How do you create the model?
&lt;ul class="org-ul"&gt;
&lt;li&gt;what is the appropriate algorithm?&lt;/li&gt;
&lt;li&gt;what is the correct metric?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;How do you evaluate the model in a real world situation?&lt;/li&gt;
&lt;li&gt;How do you deploy the model?
&lt;ul class="org-ul"&gt;
&lt;li&gt;How do you monitor its performance?&lt;/li&gt;
&lt;li&gt;How do you update it over time?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd4f6943" class="outline-2"&gt;
&lt;h2 id="orgd4f6943"&gt;A Competition Pipeline&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd4f6943"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;How do you pre-process the data?&lt;/li&gt;
&lt;li&gt;How do you create the model?&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org401b68b" class="outline-2"&gt;
&lt;h2 id="org401b68b"&gt;So, how do you use a competition then?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org401b68b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;It's good to learn about machine learning&lt;/li&gt;
&lt;li&gt;It' not just about the algorithms, let the data guide what you do&lt;/li&gt;
&lt;li&gt;Try to be creative and do things that haven't been done before&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>basics kaggle</category><guid>https://necromuralist.github.io/Kaggle-Competitions/posts/real-world-vs-kaggle/</guid><pubDate>Sun, 05 Aug 2018 01:02:24 GMT</pubDate></item></channel></rss>